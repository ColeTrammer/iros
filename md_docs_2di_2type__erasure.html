<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.10.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Iros: Type Erasure</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    Iros
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2di_2type__erasure.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Type Erasure</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md85"></a> Down with virtual methods.</p>
<h1><a class="anchor" id="autotoc_md86"></a>
Traditional OOP</h1>
<p>In normal C++, you would use a virtual interface to enable runtime polymorphism.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IDrawable {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> IDrawable() = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>() = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Square : <span class="keyword">public</span> IDrawable {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::println(<span class="stringliteral">&quot;Draw square.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Circle : <span class="keyword">public</span> IDrawable {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::println(<span class="stringliteral">&quot;Draw circle.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="agfx__test_8cpp_html_a7f0a2b3907c5aaf21cda8496849eef7d"><div class="ttname"><a href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a></div><div class="ttdeci">void draw(byte *data)</div><div class="ttdef"><b>Definition</b> gfx_test.cpp:23</div></div>
</div><!-- fragment --><p>Now, to use this construction, you can pass a IDrawable by reference to a function. To actually store these things in a memory safe way, either std::unique_ptr or std::shared_ptr must be used. These types cannot be treated as values, so we must use indirection. Furthremore, the objects always have to be heap allocated.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
Type Erasure</h1>
<p>Using type erasure, the interface class poses an abstract set of requirements, and can be constructed from any type which meets them. The type internally is memory safe, by either storing the object internally (small object optimization), or on the heap using a smart pointer. Instead of using 2 indirections, the virtual table can be inline or otherwise stored using a "fat" pointer (rust dyn&amp;).</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Circle {};</div>
<div class="line"><span class="keyword">class </span>Sqaure {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Draw {</div>
<div class="line">    <span class="keyword">using </span>Type = <a class="code hl_struct" href="structdi_1_1types_1_1Method.html">di::Method</a>&lt;Draw, void(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a>&amp;)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span>(<a class="code hl_concept" href="conceptdi_1_1concepts_1_1TagInvocable.html">di::concepts::TagInvocable&lt;DrawFunction, T&amp;&gt;</a>)</div>
<div class="line">    <span class="keywordtype">void</span> <span class="keyword">operator</span>()(T&amp; object) <span class="keyword">const</span> {</div>
<div class="line">        function::tag_invoke(*<span class="keyword">this</span>, <span class="keywordtype">object</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a> = detail::DrawFunction {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>IDrawable = <a class="code hl_struct" href="structdi_1_1meta_1_1List.html">di::meta::List&lt;Draw&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>AnyDrawable = di::Any&lt;IDrawable&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tag_invoke(Draw, Circle&amp; self) {</div>
<div class="line">    std::println(<span class="stringliteral">&quot;Draw circle.&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tag_invoke(Draw, Square&amp; self) {</div>
<div class="line">    std::println(<span class="stringliteral">&quot;Draw square.&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> use_circle() {</div>
<div class="line">    <span class="keyword">auto</span> drawable = AnyDrawable(Circle {});</div>
<div class="line">    <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>(drawable);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> use_drawables() {</div>
<div class="line">    <span class="keyword">auto</span> drawables = std::vector&lt;AnyDrawable&gt; {};</div>
<div class="line">    drawables.emplace_back(Circle {});</div>
<div class="line">    drawables.emplace_back(Sqaure {});</div>
<div class="line"> </div>
<div class="line">    std::for_each(drawables, <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aconceptdi_1_1concepts_1_1TagInvocable_html"><div class="ttname"><a href="conceptdi_1_1concepts_1_1TagInvocable.html">di::concepts::TagInvocable</a></div><div class="ttdef"><b>Definition</b> tag_invoke.h:33</div></div>
<div class="ttc" id="astructdi_1_1meta_1_1List_html"><div class="ttname"><a href="structdi_1_1meta_1_1List.html">di::meta::List</a></div><div class="ttdef"><b>Definition</b> core.h:5</div></div>
<div class="ttc" id="astructdi_1_1types_1_1Method_html"><div class="ttname"><a href="structdi_1_1types_1_1Method.html">di::types::Method</a></div><div class="ttdef"><b>Definition</b> method.h:7</div></div>
<div class="ttc" id="astructdi_1_1types_1_1This_html"><div class="ttname"><a href="structdi_1_1types_1_1This.html">di::types::This</a></div><div class="ttdef"><b>Definition</b> this.h:4</div></div>
</div><!-- fragment --><p>Notice, drawables can be used directly as objects, and thus don't have to managed using smart pointers. Additionally, operations need not be defined inside the classes they operate on, which means Circle and Square can be pure data classes, and offer no functionality themselves. This allows seamlessly adding new operations without breaking code.</p>
<p>Default operations can be expressed directly in the definition of the operation. By providing such a default operation, the Draw function object will be invocable for any object, and thus every object can be erased into a drawable.</p>
<p>The tag_invoke mechanism allows type erasure without macros and without defining operations twice. However, you don't get member functions, since C++ does not have reflection and meta classes. However, not using member functions allows extending a class without modifying it, and still provides a uniform and readable way to call methods.</p>
<div class="fragment"><div class="line"><span class="comment">// OOP</span></div>
<div class="line"><span class="keywordtype">object</span>-&gt;draw();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Type erasure</span></div>
<div class="line"><a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>(<span class="keywordtype">object</span>);</div>
</div><!-- fragment --><p>Calling a free function is 2 characters shorter assuming we are already in the correct namespace, although otherwise it will be more characters to type.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Universality with Concepts</h2>
<p>When using OOP, the dispatch is always dynamic, and so relies on de-virtualization to optimize scenarios where the concrete object type is known. With type erasure, a concrete type and a polymorphic type can be used identically, and static dispatch can be used by making your function generic with a template.</p>
<div class="fragment"><div class="line"><span class="comment">// OOP: always use dynamic dispatch.</span></div>
<div class="line"><span class="keywordtype">void</span> draw3(IDrawable&amp; a) {</div>
<div class="line">    a.draw();</div>
<div class="line">    a.draw();</div>
<div class="line">    a.draw();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Type erasure: maybe use dynamic dispatch, maybe not.</span></div>
<div class="line"><span class="keywordtype">void</span> draw3(di::Impl&lt;IDrawable&gt; <span class="keyword">auto</span>&amp; a) {</div>
<div class="line">    <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>(a);</div>
<div class="line">    <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>(a);</div>
<div class="line">    <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>(a);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>di::Impl</code> is a concept which is only satisfied for types which meet the requirements laid out in the provided interface. The name is derived from rust, where traits can be required using the impl keyword.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
Ergonomic Concerns</h1>
<p>The main annoyance with this model is the creation of tag_invoke calling function objects. This can actually be automated using some meta programming on top of tag_invoke().</p>
<div class="fragment"><div class="line"><span class="comment">// OOP</span></div>
<div class="line"><span class="keyword">class </span>IDrawable {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IDrawable() = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a>() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> i32 get_area() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> debug_print()<span class="keyword"> const </span>{}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Type erasure with method definition helper.</span></div>
<div class="line"><span class="keyword">struct </span>Draw : di::Dispatcher&lt;Draw, void(di::This&amp;)&gt; {};</div>
<div class="line"><span class="keyword">struct </span>GetArea : di::Dispatcher&lt;GetArea, i32(di::This const&amp;)&gt; {};</div>
<div class="line"><span class="keyword">struct </span>DebugPrint : di::Dispatcher&lt;DebugPrint,</div>
<div class="line">    void(di::This const&amp;),</div>
<div class="line">    di::Constexpr&lt;di::into_void&gt;</div>
<div class="line">&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code hl_function" href="gfx__test_8cpp.html#a7f0a2b3907c5aaf21cda8496849eef7d">draw</a> = Draw {};</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">auto</span> get_area = GetArea {};</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code hl_enumvalue" href="namespaceiris.html#af9e625cd0539425e48bb000b2428ffc5a7124fb0438ecdd71f8efc4b105181e57">debug_print</a> = DebugPrint {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>IDrawable = <a class="code hl_struct" href="structdi_1_1meta_1_1List.html">di::meta::List</a>&lt;</div>
<div class="line">    Draw, GetArea, DebugPrint</div>
<div class="line">&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Drawable = di::Any&lt;IDrawable&gt;;</div>
<div class="line"><span class="keyword">using </span>DrawableRef = di::AnyRef&lt;IDrawable&gt;;</div>
<div class="ttc" id="anamespaceiris_html_af9e625cd0539425e48bb000b2428ffc5a7124fb0438ecdd71f8efc4b105181e57"><div class="ttname"><a href="namespaceiris.html#af9e625cd0539425e48bb000b2428ffc5a7124fb0438ecdd71f8efc4b105181e57">iris::SystemCall::debug_print</a></div><div class="ttdeci">@ debug_print</div></div>
</div><!-- fragment --><p>The idea is that the dispatch objects will implement the common CPO pattern, which is to attempt to call functions one after another. For DebugPrint, the final function object to call is di::into_void, which means that the default implenentation will just ignore arguments. This DSL for describing an interface can work without macros, and is in fact far more expressive than virtual methods, since the actual method call can use static dispatch (and so can use if constexpr).</p>
<h2><a class="anchor" id="autotoc_md90"></a>
Templated Dispatch</h2>
<p>Most type erased interfaces will be designed for type erasure, which means they will not have templated arguments. But, in other cases, the interface in question will be templated. This is the case for things like sender/receivers, function objects, <a class="el" href="namespacedi_1_1format.html">di::format</a>, etc. In these cases, an explicit signature must be provided. For <a class="el" href="namespacedi_1_1format.html">di::format</a>, a specific type erased format context will be used, or for di::Function, the type erasure can only work on callables that except the provided signature.</p>
<p>For these cases, there needs to be a way to explicitly list the signature when defining the interface requirements.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Interface = <a class="code hl_struct" href="structdi_1_1meta_1_1List.html">di::meta::List</a>&lt;</div>
<div class="line">    Method1, Method2,</div>
<div class="line">    <a class="code hl_struct" href="structdi_1_1types_1_1Method.html">di::Method</a>&lt;FunctionObject, void(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a>&amp;)&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structdi_1_1types_1_1Method.html">di::Method</a>&lt;OtherFunction, i32(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a> <span class="keyword">const</span>&amp;, i32)&gt;</div>
<div class="line">&gt;;</div>
</div><!-- fragment --><p>If we really wanted, it could be possible to overload operator-&gt; on some sort of type. The interface definition would then be a list of value types:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Interface = di::meta::ValueList&lt;</div>
<div class="line">    method1, method2,</div>
<div class="line">    di::member&lt;FunctionObject(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a>&amp;)&gt; -&gt; di::InPlaceType&lt;void&gt;,</div>
<div class="line">    di::member&lt;OtherFunction(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a> <span class="keyword">const</span>&amp;, i32)&gt; -&gt; di::InPlaceType&lt;i32&gt;</div>
<div class="line">&gt;;</div>
</div><!-- fragment --><p>This is more verbose and exotic, so probably won't be way to go.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
Expressivity for complex CPOs</h2>
<p>The dispatcher API can also be used to make defining more complicated CPOs a lot more bearable.</p>
<p>The current implementation of container::begin() is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BeginFunction;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>detail {</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">concept </span>ArrayBegin = concepts::LanguageArray&lt;meta::RemoveReference&lt;T&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">concept </span>CustomBegin = concepts::TagInvocable&lt;BeginFunction, T&gt; &amp;&amp;</div>
<div class="line">                          concepts::Iterator&lt;meta::Decay&lt;meta::TagInvokeResult&lt;BeginFunction, T&gt;&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">concept </span>MemberBegin = <span class="keyword">requires</span>(T&amp;&amp; container) {</div>
<div class="line">                              { util::forward&lt;T&gt;(container).begin() } -&gt; concepts::Iterator;</div>
<div class="line">                          };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>BeginFunction {</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span>(enable_borrowed_container(types::in_place_type&lt;meta::RemoveCV&lt;T&gt;&gt;) &amp;&amp;</div>
<div class="line">             (detail::ArrayBegin&lt;T&gt; || detail::CustomBegin&lt;T&gt; || detail::MemberBegin&lt;T&gt;) )</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> operator()(T&amp;&amp; container)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (detail::ArrayBegin&lt;T&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> container + 0;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (detail::CustomBegin&lt;T&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> function::tag_invoke(*<span class="keyword">this</span>, util::forward&lt;T&gt;(container));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> util::forward&lt;T&gt;(container).begin();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This can equivalently be written as:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>detail {</div>
<div class="line"><span class="keyword">struct </span>BeginArray {</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span>(concepts::LanguageArray&lt;meta::RemoveReference&lt;T&gt;&gt;)</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>()(T&amp;&amp; array) <span class="keyword">const</span> {</div>
<div class="line">        <span class="keywordflow">return</span> array + 0;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>BeginMember {</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> operator()(T&amp;&amp; container) <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">requires</span>(<span class="keyword">requires</span> {</div>
<div class="line">        { util::forward&lt;T&gt;(container).begin() } -&gt; concepts::Iterator;</div>
<div class="line">    })</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> util::forward&lt;T&gt;(container).begin();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>BeginFunction : TemplateDipatcher&lt;BeginFunction, meta::List&lt;</div>
<div class="line">    BeginArray(meta::_a),</div>
<div class="line">    TagInvoke(This, meta::_a),</div>
<div class="line">    BeginMemer(meta::_a)</div>
<div class="line">&gt;&gt; {};</div>
<div class="line">}</div>
</div><!-- fragment --><p>This makes use of a placeholder syntax to implicitly define template parameters of the function. This API is not yet fully fleshed out.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
Method Resolution</h2>
<p>The core machinery behind method lookup is the <code>di::Method</code> type. Instead of working on c++ functions, this works on callable function objects and injects its own implementation using tag_invoke. This allows type-erasing simple interfaces with no additional boilerplate.</p>
<p>However, this is not enough for more complicated interfaces. For example, consider the <code>di::clone()</code> function. This function has a signature of <code>T clone(T const&amp;)</code>, which is not a valid CPO signature. This is because the return type varies with the input type. This is a problem for type erasure, because the return type must be known at compile time.</p>
<p>Conceptually, what we want to have happen is for the library to replace the return type <code>T</code> with the relevant <code>di::Any</code> object which is being cloned. However, this means we cannot just call <code>di::clone</code> directly, because the return type may not be implicitly convertible to <code>di::Any</code>.</p>
<p>To support this case, the type-erased function dispatch supports a second signature which is used for method lookup. This signature takes the method as the second argument, which allows implementations to know what the type-erased return type should be.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>M = di::Method&lt;di::Tag&lt;di::clone&gt;, <a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a>(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a> <span class="keyword">const</span>&amp;)&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When trying to resolve a call to M, first this signature is checked. Notice that the provided Method tag contains the</span></div>
<div class="line"><span class="comment">// concrete return type, which enables the custom implementation to make the necessary conversions.</span></div>
<div class="line">tag_invoke(di::Tag&lt;di::clone&gt;, di::meta::MakeConcreteSignature&lt;M, di::Any&lt;...&gt;&gt; {}, <a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a> <span class="keyword">const</span>&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Then the normal signature is checked, which will try to implicitly convert the return type to the correct di::Any.</span></div>
<div class="line">di::clone(<a class="code hl_struct" href="structdi_1_1types_1_1This.html">di::This</a> <span class="keyword">const</span>&amp;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md93"></a>
Multiple types of erased objects</h1>
<p>The generic <code>di::Any</code> container supports both value and reference semantics, which can be thought of as equivalent to passing a dyn&amp; in rust. This type is 100% allocation free. This is controlled by the storage policy proivded to the template, which allows <code>di::Any</code> to model shared ownership, unique (boxed) ownership, references, only inline storage, hybrid storage, etc.</p>
<h1><a class="anchor" id="autotoc_md94"></a>
Implementation</h1>
<h2><a class="anchor" id="autotoc_md95"></a>
Object Management</h2>
<p>For the value oriented erased object, there are many considerations to be made, mainly around which operations are to be supported. If a type erased wrapper supports copying, all implementations must support copying as well. The same can be said for di CPOs, like di::clone. Making the erased object trivially relocatable greatly improves performance, because indirect calls can be ellided during move construction, but this requires all implementing types to be trivially relocatable themselves. This is mainly a problem because this information is not derived in the compiler (at least for GCC), so such a property is opt-in.</p>
<p>No indirection on moving is needed if the internal object is always heap allocated, but doing so could be wasteful. Having inline storage is very important when erasing small objects (imagine di::Function), but effectively useless if every object is large (imagine <a class="el" href="namespaceiris.html#a540cc6f38ede006fe1f3e018385b8e86">iris::IrqController</a>). As such, the internal storage policy needs to be heavily customizable.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
Virtual Table Storage</h2>
<p>Manually creating a vtable enables the programmer to micro-optimize the vtable layout as much as they please. A sensible default is to store the vtable as a "fat" pointer (separate pointer to array of function pointers), but if there is only 1 operation, it is obviously better to just store that function pointer directly. Since we will always need at least 1 operation, because the destructor must always be callable, we can expand the default inlining level to 2 or 3 operations.</p>
<p>In certain cases, one function is "hot" while the other erased functions are called much less frequently. In these scenarios, a hybrid approach should offer the best performance. This is again an area which requires extreme customizability.</p>
<h2><a class="anchor" id="autotoc_md97"></a>
Meta Object Representation</h2>
<p>To store entries in the vtable, we need compile time meta programming facilities. Vtable entries will be represented in the following structure.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>types {</div>
<div class="line"><span class="comment">// Usage: Method&lt;MyFunction, void(di::This&amp;)&gt;</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, concepts::LanguageFunction S&gt;</div>
<div class="line"><span class="keyword">struct </span>Method {</div>
<div class="line">    <span class="keyword">using </span>Type = Method;</div>
<div class="line">    <span class="keyword">using </span>Tag = T;</div>
<div class="line">    <span class="keyword">using </span>Signature = S;</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>concepts {</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>Method = InstanceOf&lt;T, types::Method&gt;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>meta {</div>
<div class="line"><span class="keyword">template</span>&lt;concepts::Method Method&gt;</div>
<div class="line"><span class="keyword">using </span>MethodTag = Method::Tag;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;concepts::Method Method&gt;</div>
<div class="line"><span class="keyword">using </span>MethodSignature = Method::Signature;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then, vtables will have an associated list of signature objects, which correspond to the vtable entries. The library will support merging vtables together, to enable erasing multiple traits into one object, and as an implementation detail, because owning structures will internally merge the user requested operations with the vtable for moving, destroying, copying, swapping, etc.</p>
<p>A list of methods will be represented directly use a <code>meta::List&lt;&gt;</code>. Thus, merging interfaces together is simply a matter of calling <code>meta::Concat&lt;&gt;</code> and <code>meta::Unique&lt;&gt;</code> on all the methods present in a list.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Object Categories</h2>
<p>To enable certain optimizations when storing type erased objects, it is necessary to categorize object functionality.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category   </th><th class="markdownTableHeadNone">Requirements   </th><th class="markdownTableHeadNone">Optimization    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Reference   </td><td class="markdownTableBodyNone">Reference must remain valid (unsafe to store)   </td><td class="markdownTableBodyNone">Only need sizeof(void*) bytes of storage, no destruction, trivial copy, non-null    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Trivial   </td><td class="markdownTableBodyNone">Trivially Copyable, Destructible   </td><td class="markdownTableBodyNone">No need to erase lifetime operations (copy, move, destruct)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Trivially Relocatable   </td><td class="markdownTableBodyNone">Move = memcpy   </td><td class="markdownTableBodyNone">No need to erase move operations, but destructor is still required    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Immovable   </td><td class="markdownTableBodyNone">Not copyable, movable   </td><td class="markdownTableBodyNone">No need to erase move/copy, but objects cannot be copied/moved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Move Only   </td><td class="markdownTableBodyNone">Movable   </td><td class="markdownTableBodyNone">No need to erase copy operations    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Copyable   </td><td class="markdownTableBodyNone">Movable and Copyable   </td><td class="markdownTableBodyNone">Copying cannot return error, all lifetime operations cannot be merged into a single vtable entry    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Infallibly cloneable   </td><td class="markdownTableBodyNone">Clone returns <code>T</code>, not <code>Result&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Clone function can never return an error    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Cloneable   </td><td class="markdownTableBodyNone">Cloneable   </td><td class="markdownTableBodyNone">None   </td></tr>
</table>
<p>Trivially relocatable objects provide a significant improvement over having a type erased move constructor. Nearly all types in C++ are trivially relocatable, with the exception of linked lists (or any self-referential data structure). The downside is that trivial relocatability is not tracked by the compiler, and so every type must manually opt-in.</p>
<p>The default object category will be move only, since this provides allow erasing nearly any object, while providing normal value semantics. This also prevents expensive copy operations from ever being called.</p>
<p>If objects need to be copied, users can make the object category cloneable, in which case a vtable entry will handle cloning, or if shared pointer semantics are required, users can use <code>AnyShared</code>, which internally stores a ref-counted type-erased object.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
Any Type Summary</h2>
<p>The following table describes the type aliases provided by the library. Notice that types which allocate memory take an additional allocator template parameter, which defaults to <code>di::DefaultAllocator</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Alias   </th><th class="markdownTableHeadNone">Storage Category   </th><th class="markdownTableHeadNone">Requirements on T   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>di::Any&lt;I&gt;</code>   </td><td class="markdownTableBodyNone"><code>Any&lt;I, HybridStorage&lt;&gt;</code>   </td><td class="markdownTableBodyNone">Moveable   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Owning polymorphic object with value semantics. This is the default storage and vtable policy used, and is good for storing any type of value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>di::AnyRef&lt;I&gt;</code>   </td><td class="markdownTableBodyNone"><code>Any&lt;I, RefStorage&gt;</code>   </td><td class="markdownTableBodyNone">Trivial   </td><td class="markdownTableBodyNone">Must be reference or function pointer   </td><td class="markdownTableBodyNone">Non-owning reference to polymorphic object. Unsafe to store, so only use when passing a parameter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>di::AnyInline&lt;I, size, align&gt;</code>   </td><td class="markdownTableBodyNone"><code>Any&lt;I, InlineStorage&lt;size, align&gt;&gt;</code>   </td><td class="markdownTableBodyNone">Moveable   </td><td class="markdownTableBodyNone"><code>sizeof(T) &lt;= size</code> and <code>alignof(T) &lt;= align</code> and Moveable   </td><td class="markdownTableBodyNone">Non-allocated owned storage. Use when the object sizes are guaranteed to be small or allocating is unacceptable, but note that objects which are too large cannot be stored.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>di::AnyUnique&lt;I, Alloc = ...&gt;</code>   </td><td class="markdownTableBodyNone"><code>Any&lt;I, UniqueStorage&lt;Alloc&gt;&gt;</code>   </td><td class="markdownTableBodyNone">Trivially Relocatable   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Always-allocated owned storage. Use when the object sizes are large or the move constructor needs to be called a lot.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>di::AnyHybrid&lt;I, storage_category, size_threshold, align_threshold, Alloc = ...&gt;</code>   </td><td class="markdownTableBodyNone"><code>Any&lt;I, HybridStorage&lt;storage_category, size_threshold, align_threshold, Alloc&gt;&gt;</code>   </td><td class="markdownTableBodyNone">Moveable   </td><td class="markdownTableBodyNone">None (but T must be small and moveable to be stored inline)   </td><td class="markdownTableBodyNone">Sometimes allocated owned storage. Use when the object size is unknown and can be small, which prevents allocating when storing some objects.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>di::AnyShared&lt;I, Alloc = ...&gt;</code>   </td><td class="markdownTableBodyNone"><code>Any&lt;I, SharedStorage&lt;Alloc&gt;&gt;</code>   </td><td class="markdownTableBodyNone">Trivially Relocatable + Copyable   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Always-allocated shared storage. Use when shared ownership is required.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md100"></a>
A Practical Example</h1>
<p>Consider a concept which current exists in di, which conceptifies any object which can have bytes written to. This interface enables writing utility functions which work on anything which is byte writable, and in particular, is used by <a class="el" href="namespacedi_1_1format.html">di::format</a> to allow printing to stdout and stderr. But, a Writer can also be implemented using memory mapped IO, or even a temporary in memory buffer which has no disk backing.</p>
<p>The C++ 20 concept definition for this trait is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>Writer = <span class="keyword">requires</span>(T&amp; writer, vocab::Span&lt;Byte const&gt; data) {</div>
<div class="line">                     { writer.write_some(data) } -&gt; SameAs&lt;Result&lt;usize&gt;&gt;;</div>
<div class="line">                     { writer.flush() } -&gt; SameAs&lt;Result&lt;void&gt;&gt;;</div>
<div class="line">                 };</div>
</div><!-- fragment --><p>However, this trait definition requires any generic algorithm to be templated, and does not allow switching a Writer implementation at runtime.</p>
<p>A type erased API definition looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>WriteSome : Dispatcher&lt;WriteSome, Result&lt;usize&gt;(This&amp;, Span&lt;Byte const&gt;)&gt; {};</div>
<div class="line"><span class="keyword">struct </span>Flush : Dispatcher&lt;Flush, Result&lt;void&gt;(This&amp;)&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">auto</span> write_some = WriteSome {};</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">auto</span> flush = Flush {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="namespacedi_1_1io.html#aa4f3d9d81f17446d93626c64e78a7ecd">Writer</a> = meta::List&lt;WriteSome, Flush&gt;;</div>
<div class="ttc" id="anamespacedi_1_1io_html_aa4f3d9d81f17446d93626c64e78a7ecd"><div class="ttname"><a href="namespacedi_1_1io.html#aa4f3d9d81f17446d93626c64e78a7ecd">di::io::Writer</a></div><div class="ttdeci">meta::List&lt; WriteSome, Flush &gt; Writer</div><div class="ttdef"><b>Definition</b> writer.h:59</div></div>
</div><!-- fragment --><p>Now imagine a BufferWriter class, which wraps any Writer and buffers repeated calls to write_some. This is done as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD: template&lt;Writer W&gt;</span></div>
<div class="line"><span class="keyword">template</span>&lt;Impl&lt;Writer&gt; W&gt;</div>
<div class="line"><span class="keyword">class </span>BufferWriter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// OLD</span></div>
<div class="line">    <span class="keyword">constexpr</span> Result&lt;usize&gt; write_some(Span&lt;Byte const&gt; data) {</div>
<div class="line">       <span class="comment">// memcpy to buffer.</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">constexpr</span> Result&lt;void&gt; flush() {</div>
<div class="line">        <a class="code hl_define" href="monad__try_8h.html#a9dfe730ca5117f714aaec45c92d87ab0">DI_TRY</a>(m_writer.write_some(<span class="comment">/* ... */</span>));</div>
<div class="line">        <span class="keywordflow">return</span> m_writer.flush();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Result&lt;usize&gt; tag_invoke(WriteSome, BufferWriter&amp; self, Span&lt;Byte const&gt;&gt; data) {</div>
<div class="line">        <span class="comment">// memcpy to buffer.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Result&lt;void&gt; tag_invoke(Flush, BufferWriter&amp; self) {</div>
<div class="line">        <a class="code hl_define" href="monad__try_8h.html#a9dfe730ca5117f714aaec45c92d87ab0">DI_TRY</a>(write_some(m_writer, <span class="comment">/* ... */</span>));</div>
<div class="line">        <span class="keywordflow">return</span> flush(m_writer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    W m_writer;</div>
<div class="line">    Array&lt;Byte, 4096&gt; m_buffer;</div>
<div class="line">};</div>
<div class="ttc" id="amonad__try_8h_html_a9dfe730ca5117f714aaec45c92d87ab0"><div class="ttname"><a href="monad__try_8h.html#a9dfe730ca5117f714aaec45c92d87ab0">DI_TRY</a></div><div class="ttdeci">#define DI_TRY(...)</div><div class="ttdef"><b>Definition</b> monad_try.h:13</div></div>
</div><!-- fragment --><p>By defining the writer concept as a type erasable interface, buffered writer can easily accept polymorphic types without difficulty. This increased flexibility makes composition more powerful. Buffered writer is itself a Writer, so it too can be erased into some polymorphic wrapper.</p>
<p>Interestingly, the member cased CPO mechanism is an instance of duck-typing, where it will accept anything which matches the interface, even if the semantics are wrong. Where as the Any trait based solution requires specific opt-in to a particular method, so a type can never be a Writer by accident.</p>
<p>As an additional bonus, extending the trait mechanism to include a default method implementation of <code>write_exactly()</code> is trivial. But since this method has a default implementation, it cannot easily be extended to member function based Writer. In practice, we would have to define <code>write_exactly</code> as a free function, and then users would have to know whether the method they wish to call is a free function or a member function. An alternative is to use CRTP, where every concrete writer class must inherit from <code>WriterInterface&lt;Self&gt;</code>. This does in fact work, but results in more code than the trait solution, while also not easily allowing polymorphic value types. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Iros Project Documentation</a></li><li class="navelem"><a class="el" href="md_docs_2di_2table__of__contents.html">Di Library Documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
