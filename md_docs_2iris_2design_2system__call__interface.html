<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.10.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Iros: System Call Interface</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    Iros
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2iris_2design_2system__call__interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">System Call Interface</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md190"></a> </p>
<h1><a class="anchor" id="autotoc_md191"></a>
Traditional Model for System Calls</h1>
<p>On x86_64, there are 2 mechanism for performing system calls. The first option, which is essentially for backwards compatibility, is to programmatically generate an interrupt into the kernel.</p>
<p>The modern approach is using amd64's dedicated <code>syscall</code> instruction, which transfers control directly to the kernel.</p>
<p>Both these mechanisms effectively context switch into the kernel. As such, the kernel is free to reschedule the calling task at this point, and can also block the task if necessary.</p>
<h1><a class="anchor" id="autotoc_md192"></a>
Asynchronous Model for System Calls</h1>
<p>Under Linux's io_uring mechanism, kernel system calls can effectively be performed without even context switching into the kernel. This is done by having userspace and the kernel communicate through ring buffers. If the kernel has a dedicating polling thread, it never needs to be woken up by the calling task.</p>
<p>However, in most cases, the userspace code needs to call io_uring_enter(), which gives the kernel a change to process the queued system calls. This can still be efficent than performing synchronous system calls, even for trivial operations, since the system calls can be batched together (which reduces the number of context switches required).</p>
<h1><a class="anchor" id="autotoc_md193"></a>
Asynchronous First System Calls</h1>
<p>In the Iris kernel, system calls must be asynchronous first, in order to allow for high throughput scaling. However, most userspace code uses synchronous APIs, and even most asynchronous code uses readyness based APIs (think poll (2) or select (2)), which the Iris kernel will use a completion based API. As a consequence, care must be taken to ensure the approach chosen is capable of emulating these other APIs.</p>
<p>The idea is that internally, system calls which should be asynchronous will be modelled as asychronous. There will be a io_uring like mechanism which allows userspace to submit multiple system calls at once. However, there will also be a normal system call ABI, which implicitly blocks for the asynchronous underlying API to complete. This will be used to emulate synchronous APIs for compatibility.</p>
<h2><a class="anchor" id="autotoc_md194"></a>
ABI</h2>
<p>It is typical to support passing 6 arguments to system calls, so the kernel system call queue will be sized to fit exactly 6 arguments. This will ensure that from an API perspective, system calls using the queue will be the same as calling the explicitly synchronous version.</p>
<h2><a class="anchor" id="autotoc_md195"></a>
Note on Null-Terminated Strings</h2>
<p>The POSIX C API passes paths as null-terminated C strings. This prevents applications which support view types, like C++ and Rust, from easily using these APIs. In fact, the view types usually have to be copied simply to add a zero to the end of the buffer. Null-terminated strings are also far more annoying to deal with in the kernel.</p>
<p>As a consequence, the Iris kernel will not support null-terminated strings. Instead, system call arguments will be passe as a pointer + size pair. When emulating POSIX APIs, the system call wrapper must call <code>strlen</code> before entering the kernel.</p>
<h2><a class="anchor" id="autotoc_md196"></a>
Emulating Readyness APIs</h2>
<p>With this approach, modelling readiness can be done by making an asynchronous query, which effectively completes when the resource is ready. Userspace can simply submit one of these requests when the caller a blocking function, and then it will wait on for completion.</p>
<p>It is also possible to emulate readyness purely in userspace, by giving file descriptors a private buffer. Then, a readiness query would complete when either data arrives in the better or there is now extra space in the buffer. This may prove difficult to achieve, especially when considering non-blocking reads.</p>
<h2><a class="anchor" id="autotoc_md197"></a>
Emulating Traditional Non-blocking IO</h2>
<p>Emulating non-blocking read requests is the tricky part. Imagine trying to read data from a internet socket. Using a pure completion API, the only way to know if data is ready is to submit a read request and wait for it to complete. However, we want to return immediately if there is no data. This can of course be done by having a special mode when reading data which never blocks, but that would be non-general and most likely make code a lot more complicated.</p>
<p>One idea is to use some sort of time out mechanism, which will try to cancel the IO request after a set amount of time. If the timeout is 0, the operation must complete immediately. However, depending on how this is implemented, it may require spinning up a background worker only to immediately cancel it.</p>
<h1><a class="anchor" id="autotoc_md198"></a>
Task Creation</h1>
<p>Traditionally, unix systems use a combination of <code>fork</code> and <code>exec</code> to implement task creation. This approach is not maximally efficent, because <code>fork</code> requires creating a COW mapping of the process's address space. What's worse is that in most cases, this the created process's address space is immediately thrown away by a call to <code>exec</code>. As such, the Iris kernel will not implement task creation using this API.</p>
<p>Instead, the Iris kernel will support a rich set of system calls for task creation. For instance, to create a new process from some binary, a userspace program would be expected to submit the following multiple system calls:</p>
<ol type="1">
<li>create_task (which will create a new kernel task, with no attributes set)</li>
<li>load_executable (which will initialize the tasks address space)</li>
<li>share_files (which will give the new task access to stdin, stdout, and stderr)</li>
<li>start_task (which will schedule the task now that it has been fully initialized)</li>
</ol>
<p>One point to note is that because the underlying system call API will allow for queueing multiple system calls at once, this will not require performing more than one context switch to create the new task. Additionally, a system call like share_files can be generally useful outside of task creation, and maybe can be used with running tasks as well. More generally, a system call in POSIX like <code>setpgid</code> will be implemented in the Iris kernel as <code>set_task_pgid</code>, and take the task whose process group id should be set as the first argument. In this way, the <code>set_task_pgid</code> can be used both to set another tasks process group id, as well as its own. This ensures that this task creation mechanism won't require duplicating a large number of system calls.</p>
<h2><a class="anchor" id="autotoc_md199"></a>
Emulating POSIX</h2>
<p>It's clear that the above mechanism can support <code>posix_spawn</code>, given that each system call involved could map directly to an "action" in terms of <code>posix_spawn</code>.</p>
<p>More interestingly is how <code>fork</code> can be emulated using this mechanism. All that is needed is for the kernel to provide a dedicated system call, such as <code>create_cow_mapping</code>, which will give the newly created task a copy of another address space. In combination with some additional system calls for directly modifying a task's state, such as <code>set_instruction_pointer</code> and <code>set_cpu_register</code>, the exact API of fork() can be emulated. Of course, anything shared accross <code>fork</code> would require some system call which duplicates the resource to the newly created task, but for most attributes this will be necessary anyway, without even considering supporting <code>fork</code>.</p>
<p>A <code>fork</code> emulating with slightly different semantics can likely be used to implement <code>vfork</code> as well, although POSIX applications which use <code>vfork</code> should probably be written to use <code>posix_spawn</code> instead whenever possible, which will ensure that their process creation strategy will be optimized for the target platform.</p>
<h1><a class="anchor" id="autotoc_md200"></a>
Platform Specific ABI</h1>
<h2><a class="anchor" id="autotoc_md201"></a>
x86_64</h2>
<p>For synchronous system calls, the calling convention will be identical to Linux's. In particular, the arguments will be passed in the following registers. Note that we cannot use the regular SYS-V calling convention because the <code>rcx</code> and <code>r11</code> registers is clobbered when using the <code>syscall</code> instruction.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ABI Component   </th><th class="markdownTableHeadNone">CPU Register   </th><th class="markdownTableHeadNone">Clobbered    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">System Call Number   </td><td class="markdownTableBodyNone"><code>rax</code>   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Argument 1   </td><td class="markdownTableBodyNone"><code>rdi</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Argument 2   </td><td class="markdownTableBodyNone"><code>rsi</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Argument 3   </td><td class="markdownTableBodyNone"><code>rdx</code>   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Argument 4   </td><td class="markdownTableBodyNone"><code>r10</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Argument 5   </td><td class="markdownTableBodyNone"><code>r8</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Argument 6   </td><td class="markdownTableBodyNone"><code>r9</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Saved <code>rip</code>   </td><td class="markdownTableBodyNone"><code>rcx</code>   </td><td class="markdownTableBodyNone">Yes (when using <code>syscall</code> instruction)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Saved <code>rflags</code>   </td><td class="markdownTableBodyNone"><code>r11</code>   </td><td class="markdownTableBodyNone">Yes (when using <code>syscall</code> instruction)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Flags Register   </td><td class="markdownTableBodyNone"><code>rflags</code>   </td><td class="markdownTableBodyNone">Yes (kernel may mutate userspace <code>rflags</code> before returning)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Success Return   </td><td class="markdownTableBodyNone"><code>rax</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Error Return   </td><td class="markdownTableBodyNone"><code>rdx</code>   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Note that this does differ from the linux system call abi in that the return value is sent through 2 registers. On Linux, error conditions are represented using negative return values of <code>rax</code>. Instead, the Iris kernel sets <code>rdx</code> to 0 on success, and <code>rdx</code> will be non-zero when an error occurs. This extension makes checking for error conditions simpler for all system calls, and ensures the return value can use the full range of 64 bit values. It is imagined that this distinction can also enable APIs to report partial success, for instance, in scenarios where a disk read is only able to complete parts of the request.</p>
<p>An alternative ABI for indicating an error would be to have to kernel directly set one of the bits in <code>flags</code>, and have the caller branch on that. This has the benefit of not clobbering the <code>rdx</code> register but is far more challenging to use with inline assembly.</p>
<p>Additionally, the Iris kernel will support the <code>syscall</code> instruction in the future, but currently implements system calls using the 128th interrupt. Support for this should be removed once <code>syscall</code> is added, because Iros does not need to worry about backwards compatibility. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Iros Project Documentation</a></li><li class="navelem"><a class="el" href="md_docs_2iris_2table__of__contents.html">Iris Kernel Documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
