<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.10.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Iros: di::execution Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    Iros
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacedi_1_1execution.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">di::execution Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1as__awaitable__ns" id="r_namespacedi_1_1execution_1_1as__awaitable__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1as__awaitable__ns.html">as_awaitable_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1async__generator__ns" id="r_namespacedi_1_1execution_1_1async__generator__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1async__generator__ns.html">async_generator_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1async__open__ns" id="r_namespacedi_1_1execution_1_1async__open__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1async__open__ns.html">async_open_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1async__read__exactly__ns" id="r_namespacedi_1_1execution_1_1async__read__exactly__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1async__read__exactly__ns.html">async_read_exactly_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1async__read__some__ns" id="r_namespacedi_1_1execution_1_1async__read__some__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1async__read__some__ns.html">async_read_some_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1async__write__exactly__ns" id="r_namespacedi_1_1execution_1_1async__write__exactly__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1async__write__exactly__ns.html">async_write_exactly_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1async__write__some__ns" id="r_namespacedi_1_1execution_1_1async__write__some__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1async__write__some__ns.html">async_write_some_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1bulk__ns" id="r_namespacedi_1_1execution_1_1bulk__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1bulk__ns.html">bulk_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1connect__awaitable__ns" id="r_namespacedi_1_1execution_1_1connect__awaitable__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1connect__awaitable__ns.html">connect_awaitable_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1counting__scope__ns" id="r_namespacedi_1_1execution_1_1counting__scope__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1counting__scope__ns.html">counting_scope_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1detail" id="r_namespacedi_1_1execution_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1dummy__ns" id="r_namespacedi_1_1execution_1_1dummy__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1dummy__ns.html">dummy_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1empty__sequence__ns" id="r_namespacedi_1_1execution_1_1empty__sequence__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1empty__sequence__ns.html">empty_sequence_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1ensure__started__ns" id="r_namespacedi_1_1execution_1_1ensure__started__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1ensure__started__ns.html">ensure_started_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1execute__ns" id="r_namespacedi_1_1execution_1_1execute__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1execute__ns.html">execute_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1filter__ns" id="r_namespacedi_1_1execution_1_1filter__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1filter__ns.html">filter_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1first__value__ns" id="r_namespacedi_1_1execution_1_1first__value__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1first__value__ns.html">first_value_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1from__container__ns" id="r_namespacedi_1_1execution_1_1from__container__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1from__container__ns.html">from_container_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1get__sequence__cardinality__ns" id="r_namespacedi_1_1execution_1_1get__sequence__cardinality__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1get__sequence__cardinality__ns.html">get_sequence_cardinality_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1ignore__all__ns" id="r_namespacedi_1_1execution_1_1ignore__all__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1ignore__all__ns.html">ignore_all_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1into__lockstep__sequence__ns" id="r_namespacedi_1_1execution_1_1into__lockstep__sequence__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1into__lockstep__sequence__ns.html">into_lockstep_sequence_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1into__result__ns" id="r_namespacedi_1_1execution_1_1into__result__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1into__result__ns.html">into_result_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1into__variant__each__ns" id="r_namespacedi_1_1execution_1_1into__variant__each__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1into__variant__each__ns.html">into_variant_each_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1into__variant__ns" id="r_namespacedi_1_1execution_1_1into__variant__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1into__variant__ns.html">into_variant_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1ipc" id="r_namespacedi_1_1execution_1_1ipc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1ipc.html">ipc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1ipc__binary__ns" id="r_namespacedi_1_1execution_1_1ipc__binary__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1ipc__binary__ns.html">ipc_binary_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1is__always__lockstop__sequence__ns" id="r_namespacedi_1_1execution_1_1is__always__lockstop__sequence__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1is__always__lockstop__sequence__ns.html">is_always_lockstop_sequence_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1is__debug__env__ns" id="r_namespacedi_1_1execution_1_1is__debug__env__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1is__debug__env__ns.html">is_debug_env_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1just__from__ns" id="r_namespacedi_1_1execution_1_1just__from__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1just__from__ns.html">just_from_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1just__ns" id="r_namespacedi_1_1execution_1_1just__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1just__ns.html">just_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1just__or__error__ns" id="r_namespacedi_1_1execution_1_1just__or__error__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1just__or__error__ns.html">just_or_error_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1just__void__or__stopped__ns" id="r_namespacedi_1_1execution_1_1just__void__or__stopped__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1just__void__or__stopped__ns.html">just_void_or_stopped_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1lazy__ns" id="r_namespacedi_1_1execution_1_1lazy__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1lazy__ns.html">lazy_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1let__each__ns" id="r_namespacedi_1_1execution_1_1let__each__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1let__each__ns.html">let_each_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1let__ns" id="r_namespacedi_1_1execution_1_1let__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1let__ns.html">let_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1let__value__with__ns" id="r_namespacedi_1_1execution_1_1let__value__with__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1let__value__with__ns.html">let_value_with_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1make__env__ns" id="r_namespacedi_1_1execution_1_1make__env__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1make__env__ns.html">make_env_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1nest__ns" id="r_namespacedi_1_1execution_1_1nest__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1nest__ns.html">nest_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1next__ns" id="r_namespacedi_1_1execution_1_1next__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1next__ns.html">next_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1on__ns" id="r_namespacedi_1_1execution_1_1on__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1on__ns.html">on_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1read__ns" id="r_namespacedi_1_1execution_1_1read__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1read__ns.html">read_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1receiver__interface__ns" id="r_namespacedi_1_1execution_1_1receiver__interface__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1receiver__interface__ns.html">receiver_interface_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1repeat__effect__ns" id="r_namespacedi_1_1execution_1_1repeat__effect__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1repeat__effect__ns.html">repeat_effect_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1repeat__effect__until__ns" id="r_namespacedi_1_1execution_1_1repeat__effect__until__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1repeat__effect__until__ns.html">repeat_effect_until_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1repeat__ns" id="r_namespacedi_1_1execution_1_1repeat__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1repeat__ns.html">repeat_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1request__stop__ns" id="r_namespacedi_1_1execution_1_1request__stop__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1request__stop__ns.html">request_stop_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1run__ns" id="r_namespacedi_1_1execution_1_1run__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1run__ns.html">run_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1schedule__from__ns" id="r_namespacedi_1_1execution_1_1schedule__from__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1schedule__from__ns.html">schedule_from_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1send__ns" id="r_namespacedi_1_1execution_1_1send__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1send__ns.html">send_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1sender__to__sequence__adaptor__ns" id="r_namespacedi_1_1execution_1_1sender__to__sequence__adaptor__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1sender__to__sequence__adaptor__ns.html">sender_to_sequence_adaptor_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1set__next__ns" id="r_namespacedi_1_1execution_1_1set__next__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1set__next__ns.html">set_next_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1spawn__future__ns" id="r_namespacedi_1_1execution_1_1spawn__future__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1spawn__future__ns.html">spawn_future_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1spawn__ns" id="r_namespacedi_1_1execution_1_1spawn__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1spawn__ns.html">spawn_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1split__ns" id="r_namespacedi_1_1execution_1_1split__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1split__ns.html">split_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1start__detached__ns" id="r_namespacedi_1_1execution_1_1start__detached__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1start__detached__ns.html">start_detached_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1stopped__as__error__ns" id="r_namespacedi_1_1execution_1_1stopped__as__error__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1stopped__as__error__ns.html">stopped_as_error_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1stopped__as__optional__ns" id="r_namespacedi_1_1execution_1_1stopped__as__optional__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1stopped__as__optional__ns.html">stopped_as_optional_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1subscribe__ns" id="r_namespacedi_1_1execution_1_1subscribe__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1subscribe__ns.html">subscribe_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1sync__wait__ns" id="r_namespacedi_1_1execution_1_1sync__wait__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1sync__wait__ns.html">sync_wait_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1then__each__ns" id="r_namespacedi_1_1execution_1_1then__each__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1then__each__ns.html">then_each_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1then__ns" id="r_namespacedi_1_1execution_1_1then__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1then__ns.html">then_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1transfer__just__ns" id="r_namespacedi_1_1execution_1_1transfer__just__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1transfer__just__ns.html">transfer_just_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1transfer__ns" id="r_namespacedi_1_1execution_1_1transfer__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1transfer__ns.html">transfer_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1transform__each__ns" id="r_namespacedi_1_1execution_1_1transform__each__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1transform__each__ns.html">transform_each_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1use__resources__ns" id="r_namespacedi_1_1execution_1_1use__resources__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1use__resources__ns.html">use_resources_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1when__all__ns" id="r_namespacedi_1_1execution_1_1when__all__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1when__all__ns.html">when_all_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1with__env__ns" id="r_namespacedi_1_1execution_1_1with__env__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1with__env__ns.html">with_env_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedi_1_1execution_1_1zip__ns" id="r_namespacedi_1_1execution_1_1zip__ns"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedi_1_1execution_1_1zip__ns.html">zip_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1AnyReceiverT.html">AnyReceiverT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1AnySenderOfT.html">AnySenderOfT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1AnySenderT.html">AnySenderT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1EnvPromise.html">EnvPromise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1ForwardingQuery.html">ForwardingQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1GetCompletionScheduler.html">GetCompletionScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1InlineScheduler.html">InlineScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1Protocol.html">Protocol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdi_1_1execution_1_1RunLoop.html">RunLoop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1SequenceTag.html">SequenceTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdi_1_1execution_1_1WithAwaitableSenders.html">WithAwaitableSenders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdi_1_1execution_1_1WithAwaitTransform.html">WithAwaitTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptdi_1_1execution_1_1Scope.html">Scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type which models an async scope. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a26e4d17bd7f053f793177316211c2bb8" id="r_a26e4d17bd7f053f793177316211c2bb8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e4d17bd7f053f793177316211c2bb8">Stopped</a> = decltype(<a class="el" href="#ad5dfbc3a12da3fdb5f57e8117230de9f">just_stopped</a>())</td></tr>
<tr class="separator:a26e4d17bd7f053f793177316211c2bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc6f39a4e48ca67d9020f7837f6ec08" id="r_abfc6f39a4e48ca67d9020f7837f6ec08"><td class="memTemplParams" colspan="2">template&lt;concepts::Interface Interface, typename Env &gt; </td></tr>
<tr class="memitem:abfc6f39a4e48ca67d9020f7837f6ec08"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfc6f39a4e48ca67d9020f7837f6ec08">InterfaceWithEnv</a></td></tr>
<tr class="separator:abfc6f39a4e48ca67d9020f7837f6ec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140f587339eadd05e451ea025554b638" id="r_a140f587339eadd05e451ea025554b638"><td class="memTemplParams" colspan="2">template&lt;typename Env  = void, concepts::AnyStorage Storage = any::HybridStorage&lt;any::StorageCategory::MoveOnly, 8 * sizeof(void*), alignof(void*)&gt;, typename VTablePolicy  = any::MaybeInlineVTable&lt;3&gt;&gt; </td></tr>
<tr class="memitem:a140f587339eadd05e451ea025554b638"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a140f587339eadd05e451ea025554b638">AnyOperationState</a> = Any&lt;<a class="el" href="#abfc6f39a4e48ca67d9020f7837f6ec08">InterfaceWithEnv</a>&lt;<a class="el" href="structdi_1_1meta_1_1List.html">meta::List</a>&lt;<a class="el" href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">types::Tag</a>&lt;<a class="el" href="#a4489f2f3c368ba297e8982d77dd3e27d">execution::start</a>&gt;&gt;, Env&gt;, Storage, VTablePolicy&gt;</td></tr>
<tr class="separator:a140f587339eadd05e451ea025554b638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fc7858870e05c42481fac582dcedeb" id="r_af9fc7858870e05c42481fac582dcedeb"><td class="memTemplParams" colspan="2">template&lt;concepts::ValidCompletionSignatures Sigs, typename Env  = void, concepts::AnyStorage Storage = any::InlineStorage&lt;2 * sizeof(void*), alignof(void*)&gt;, typename VTablePolicy  = any::MaybeInlineVTable&lt;3&gt;&gt; </td></tr>
<tr class="memitem:af9fc7858870e05c42481fac582dcedeb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9fc7858870e05c42481fac582dcedeb">AnyReceiver</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1AnyReceiverT.html">AnyReceiverT</a>&lt;Sigs, Env, Storage, VTablePolicy&gt;&gt;</td></tr>
<tr class="separator:af9fc7858870e05c42481fac582dcedeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f6c0b5170bad93bef48f2942c67c6" id="r_a098f6c0b5170bad93bef48f2942c67c6"><td class="memTemplParams" colspan="2">template&lt;concepts::ValidCompletionSignatures Sigs, typename Env  = void, concepts::AnyStorage Storage = any::HybridStorage&lt;&gt;, typename VTablePolicy  = any::MaybeInlineVTable&lt;3&gt;, concepts::OperationState Op = AnyOperationState&lt;&gt;, typename Rec  = AnyReceiver&lt;detail::AnySigs&lt;Sigs&gt;&gt;&gt; </td></tr>
<tr class="memitem:a098f6c0b5170bad93bef48f2942c67c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a098f6c0b5170bad93bef48f2942c67c6">AnySender</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1AnySenderT.html">AnySenderT</a>&lt;Sigs, Env, Storage, VTablePolicy, Op, Rec&gt;&gt;</td></tr>
<tr class="separator:a098f6c0b5170bad93bef48f2942c67c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3d18b9a4deba93f4bfa582edc376b" id="r_ad4b3d18b9a4deba93f4bfa582edc376b"><td class="memTemplParams" colspan="2">template&lt;typename T  = void&gt; </td></tr>
<tr class="memitem:ad4b3d18b9a4deba93f4bfa582edc376b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4b3d18b9a4deba93f4bfa582edc376b">AnySenderOf</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1AnySenderOfT.html">AnySenderOfT</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:ad4b3d18b9a4deba93f4bfa582edc376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989f3f0c1225b688e96d0b2d239fbb45" id="r_a989f3f0c1225b688e96d0b2d239fbb45"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Val &gt; </td></tr>
<tr class="memitem:a989f3f0c1225b688e96d0b2d239fbb45"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a989f3f0c1225b688e96d0b2d239fbb45">With</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1With.html">make_env_ns::With</a>&lt;Tag, Val&gt;</td></tr>
<tr class="memdesc:a989f3f0c1225b688e96d0b2d239fbb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a override for an environment query.  <br /></td></tr>
<tr class="separator:a989f3f0c1225b688e96d0b2d239fbb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b90e8571ceb6ef63751a2bcaccc83ec" id="r_a6b90e8571ceb6ef63751a2bcaccc83ec"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a6b90e8571ceb6ef63751a2bcaccc83ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b90e8571ceb6ef63751a2bcaccc83ec">Without</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1Without.html">make_env_ns::Without</a>&lt;Tag&gt;</td></tr>
<tr class="memdesc:a6b90e8571ceb6ef63751a2bcaccc83ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a removal of an environment query value.  <br /></td></tr>
<tr class="separator:a6b90e8571ceb6ef63751a2bcaccc83ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97dc746831b601122b2fa9a60356aa4" id="r_aa97dc746831b601122b2fa9a60356aa4"><td class="memTemplParams" colspan="2">template&lt;typename BaseEnv , typename... Withs&gt; </td></tr>
<tr class="memitem:aa97dc746831b601122b2fa9a60356aa4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa97dc746831b601122b2fa9a60356aa4">MakeEnv</a> = decltype(<a class="el" href="#a59274784714d063ff3e706df9ad50e9c">make_env</a>(<a class="el" href="namespacedi_1_1util.html#adabf7c526a3f93dfe8d610923a1579a9">util::declval</a>&lt;BaseEnv&gt;(), <a class="el" href="namespacedi_1_1util.html#adabf7c526a3f93dfe8d610923a1579a9">util::declval</a>&lt;Withs&gt;()...))</td></tr>
<tr class="memdesc:aa97dc746831b601122b2fa9a60356aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an environment with overrides for queries.  <br /></td></tr>
<tr class="separator:aa97dc746831b601122b2fa9a60356aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9910ac14eb1ff31dadbc731a662e76" id="r_a7a9910ac14eb1ff31dadbc731a662e76"><td class="memTemplParams" colspan="2">template&lt;concepts::ClassType Self, concepts::Receiver Base = receiver_interface_ns::fake_receiver::FakeReceiver&gt; </td></tr>
<tr class="memitem:a7a9910ac14eb1ff31dadbc731a662e76"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a9910ac14eb1ff31dadbc731a662e76">ReceiverAdaptor</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1receiver__interface__ns_1_1ReceiverAdaptor.html">receiver_interface_ns::ReceiverAdaptor</a>&lt;Self, Base&gt;&gt;</td></tr>
<tr class="separator:a7a9910ac14eb1ff31dadbc731a662e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da9ade646e9b5e956bb30a00fccff27" id="r_a4da9ade646e9b5e956bb30a00fccff27"><td class="memTemplParams" colspan="2">template&lt;concepts::Allocator Alloc = platform::DefaultAllocator&gt; </td></tr>
<tr class="memitem:a4da9ade646e9b5e956bb30a00fccff27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4da9ade646e9b5e956bb30a00fccff27">CountingScope</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1counting__scope__ns_1_1CountingScopeT.html">counting_scope_ns::CountingScopeT</a>&lt;Alloc&gt;&gt;</td></tr>
<tr class="memdesc:a4da9ade646e9b5e956bb30a00fccff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scope that waits for all spawned senders to complete.  <br /></td></tr>
<tr class="separator:a4da9ade646e9b5e956bb30a00fccff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765a5e7168d2f4aded33132da901aadb" id="r_a765a5e7168d2f4aded33132da901aadb"><td class="memTemplParams" colspan="2">template&lt;typename Ref , typename Value  = void&gt; </td></tr>
<tr class="memitem:a765a5e7168d2f4aded33132da901aadb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a765a5e7168d2f4aded33132da901aadb">AsyncGenerator</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1async__generator__ns_1_1AsyncGeneratorT.html">async_generator_ns::AsyncGeneratorT</a>&lt;Ref, Value&gt;&gt;</td></tr>
<tr class="separator:a765a5e7168d2f4aded33132da901aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1bf5633424c5fd8590c971cdb26aee22" id="r_a1bf5633424c5fd8590c971cdb26aee22"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf5633424c5fd8590c971cdb26aee22">ForwardProgressGuarantee</a> { <a class="el" href="#a1bf5633424c5fd8590c971cdb26aee22a3aee746018287558354fbcd7dd8bb904">Concurrent</a>
, <a class="el" href="#a1bf5633424c5fd8590c971cdb26aee22a98402eecfbcefc336954458a01752131">Parallel</a>
, <a class="el" href="#a1bf5633424c5fd8590c971cdb26aee22a066bf4627e8236d8533e7001aaa8c228">WeaklyParallel</a>
 }</td></tr>
<tr class="separator:a1bf5633424c5fd8590c971cdb26aee22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a69b45f0c066c4f960ee10a8e6502fbac" id="r_a69b45f0c066c4f960ee10a8e6502fbac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69b45f0c066c4f960ee10a8e6502fbac">bulk</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1bulk__ns_1_1Function.html">bulk_ns::Function</a> {}, c_&lt;3zu&gt;)</td></tr>
<tr class="memdesc:a69b45f0c066c4f960ee10a8e6502fbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk apply a function to a range of values.  <br /></td></tr>
<tr class="separator:a69b45f0c066c4f960ee10a8e6502fbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d29b9f071f6a569fae4e28807e09b41" id="r_a1d29b9f071f6a569fae4e28807e09b41"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d29b9f071f6a569fae4e28807e09b41">ensure_started</a> = <a class="el" href="structdi_1_1execution_1_1ensure__started__ns_1_1Function.html">ensure_started_ns::Function</a> {}</td></tr>
<tr class="memdesc:a1d29b9f071f6a569fae4e28807e09b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly start a sender.  <br /></td></tr>
<tr class="separator:a1d29b9f071f6a569fae4e28807e09b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dff2641cb301865688bd130e8a37a24" id="r_a6dff2641cb301865688bd130e8a37a24"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dff2641cb301865688bd130e8a37a24">execute</a> = <a class="el" href="structdi_1_1execution_1_1execute__ns_1_1Function.html">execute_ns::Function</a> {}</td></tr>
<tr class="memdesc:a6dff2641cb301865688bd130e8a37a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a function on a scheduler.  <br /></td></tr>
<tr class="separator:a6dff2641cb301865688bd130e8a37a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c563c907f1d1b9bea53a1b0dfeea6d2" id="r_a6c563c907f1d1b9bea53a1b0dfeea6d2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c563c907f1d1b9bea53a1b0dfeea6d2">into_result</a> = <a class="el" href="structdi_1_1execution_1_1into__result__ns_1_1Function.html">into_result_ns::Function</a> {}</td></tr>
<tr class="separator:a6c563c907f1d1b9bea53a1b0dfeea6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbcaf8247a09df60b1e5ef786f58e18" id="r_accbcaf8247a09df60b1e5ef786f58e18"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accbcaf8247a09df60b1e5ef786f58e18">into_variant_result</a> = <a class="el" href="structdi_1_1execution_1_1into__result__ns_1_1VariantFunction.html">into_result_ns::VariantFunction</a> {}</td></tr>
<tr class="separator:accbcaf8247a09df60b1e5ef786f58e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b4ee8d7a0e7e7160c5cdcb719a8964" id="r_a46b4ee8d7a0e7e7160c5cdcb719a8964"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b4ee8d7a0e7e7160c5cdcb719a8964">into_variant</a> = <a class="el" href="structdi_1_1execution_1_1into__variant__ns_1_1Function.html">into_variant_ns::Function</a> {}</td></tr>
<tr class="separator:a46b4ee8d7a0e7e7160c5cdcb719a8964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0227de21744a54490113644cf720e1" id="r_afd0227de21744a54490113644cf720e1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd0227de21744a54490113644cf720e1">just</a> = <a class="el" href="structdi_1_1execution_1_1just__ns_1_1Function.html">just_ns::Function</a> {}</td></tr>
<tr class="separator:afd0227de21744a54490113644cf720e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b26457a62e1f788c51d33b0c5cc1215" id="r_a3b26457a62e1f788c51d33b0c5cc1215"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b26457a62e1f788c51d33b0c5cc1215">just_error</a> = <a class="el" href="structdi_1_1execution_1_1just__ns_1_1ErrorFunction.html">just_ns::ErrorFunction</a> {}</td></tr>
<tr class="separator:a3b26457a62e1f788c51d33b0c5cc1215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dfbc3a12da3fdb5f57e8117230de9f" id="r_ad5dfbc3a12da3fdb5f57e8117230de9f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5dfbc3a12da3fdb5f57e8117230de9f">just_stopped</a> = <a class="el" href="structdi_1_1execution_1_1just__ns_1_1StoppedFunction.html">just_ns::StoppedFunction</a> {}</td></tr>
<tr class="separator:ad5dfbc3a12da3fdb5f57e8117230de9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2793e3e2023b1588f32defbcb3545558" id="r_a2793e3e2023b1588f32defbcb3545558"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2793e3e2023b1588f32defbcb3545558">stopped</a> = <a class="el" href="#ad5dfbc3a12da3fdb5f57e8117230de9f">just_stopped</a>()</td></tr>
<tr class="separator:a2793e3e2023b1588f32defbcb3545558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6346585630476aa77499b6dd569fe66" id="r_aa6346585630476aa77499b6dd569fe66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6346585630476aa77499b6dd569fe66">just_from</a> = <a class="el" href="structdi_1_1execution_1_1just__from__ns_1_1Function.html">just_from_ns::Function</a> {}</td></tr>
<tr class="memdesc:aa6346585630476aa77499b6dd569fe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sender from a function.  <br /></td></tr>
<tr class="separator:aa6346585630476aa77499b6dd569fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2885b280666f68bcc51f6a3a518105a" id="r_ab2885b280666f68bcc51f6a3a518105a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2885b280666f68bcc51f6a3a518105a">just_or_error</a> = <a class="el" href="structdi_1_1execution_1_1just__or__error__ns_1_1Function.html">just_or_error_ns::Function</a> {}</td></tr>
<tr class="separator:ab2885b280666f68bcc51f6a3a518105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637afd55af27f54b03c3fda560d0de0" id="r_a3637afd55af27f54b03c3fda560d0de0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3637afd55af27f54b03c3fda560d0de0">just_void_or_stopped</a> = <a class="el" href="structdi_1_1execution_1_1just__void__or__stopped__ns_1_1Function.html">just_void_or_stopped_ns::Function</a> {}</td></tr>
<tr class="separator:a3637afd55af27f54b03c3fda560d0de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f922bb53c516baa85b259d3cf7b6d80" id="r_a3f922bb53c516baa85b259d3cf7b6d80"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f922bb53c516baa85b259d3cf7b6d80">let_value</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__ns_1_1Function.html">let_ns::Function</a>&lt;<a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a>&gt; {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:a3f922bb53c516baa85b259d3cf7b6d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8231ee42a7b11c83375fc729faf1c967" id="r_a8231ee42a7b11c83375fc729faf1c967"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8231ee42a7b11c83375fc729faf1c967">let_error</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__ns_1_1Function.html">let_ns::Function</a>&lt;<a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a>&gt; {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:a8231ee42a7b11c83375fc729faf1c967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7f1738fde8d5bf757f0dc871910533" id="r_add7f1738fde8d5bf757f0dc871910533"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add7f1738fde8d5bf757f0dc871910533">let_stopped</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__ns_1_1Function.html">let_ns::Function</a>&lt;<a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a>&gt; {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:add7f1738fde8d5bf757f0dc871910533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205ba3e1439f9a633846ec4768b07eac" id="r_a205ba3e1439f9a633846ec4768b07eac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a205ba3e1439f9a633846ec4768b07eac">let_value_with</a> = <a class="el" href="structdi_1_1execution_1_1let__value__with__ns_1_1Function.html">let_value_with_ns::Function</a> {}</td></tr>
<tr class="memdesc:a205ba3e1439f9a633846ec4768b07eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject values into an operation state.  <br /></td></tr>
<tr class="separator:a205ba3e1439f9a633846ec4768b07eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0027f43a9c5889062402b45528dce74" id="r_af0027f43a9c5889062402b45528dce74"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0027f43a9c5889062402b45528dce74">on</a> = <a class="el" href="structdi_1_1execution_1_1on__ns_1_1Function.html">on_ns::Function</a> {}</td></tr>
<tr class="separator:af0027f43a9c5889062402b45528dce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc8cd6c50b82282b51f5a5c4a300532" id="r_a0bc8cd6c50b82282b51f5a5c4a300532"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc8cd6c50b82282b51f5a5c4a300532">read</a> = <a class="el" href="structdi_1_1execution_1_1read__ns_1_1Function.html">read_ns::Function</a> {}</td></tr>
<tr class="separator:a0bc8cd6c50b82282b51f5a5c4a300532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab964d2c321fd09ebdc6a07dcfd7122ab" id="r_ab964d2c321fd09ebdc6a07dcfd7122ab"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab964d2c321fd09ebdc6a07dcfd7122ab">repeat_effect</a> = <a class="el" href="structdi_1_1execution_1_1repeat__effect__ns_1_1Function.html">repeat_effect_ns::Function</a> {}</td></tr>
<tr class="separator:ab964d2c321fd09ebdc6a07dcfd7122ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6b0d93192d3ac5bfd91465d5d2a9b0" id="r_a7b6b0d93192d3ac5bfd91465d5d2a9b0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6b0d93192d3ac5bfd91465d5d2a9b0">repeat_effect_until</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1repeat__effect__until__ns_1_1Function.html">repeat_effect_until_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:a7b6b0d93192d3ac5bfd91465d5d2a9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89cce9805c9c6cab6b275641d3ecf0b" id="r_ae89cce9805c9c6cab6b275641d3ecf0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89cce9805c9c6cab6b275641d3ecf0b">schedule_from</a> = <a class="el" href="structdi_1_1execution_1_1schedule__from__ns_1_1Function.html">schedule_from_ns::Function</a> {}</td></tr>
<tr class="separator:ae89cce9805c9c6cab6b275641d3ecf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7e7d8e81c15fe09e8d1138a1ad9943" id="r_a8a7e7d8e81c15fe09e8d1138a1ad9943"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a7e7d8e81c15fe09e8d1138a1ad9943">split</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1split__ns_1_1Function.html">split_ns::Function</a> {}, c_&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a8a7e7d8e81c15fe09e8d1138a1ad9943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a sender into a sender which sends the same value to multiple receivers.  <br /></td></tr>
<tr class="separator:a8a7e7d8e81c15fe09e8d1138a1ad9943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346dc30954a7326dea7ad52b534a8a6d" id="r_a346dc30954a7326dea7ad52b534a8a6d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a346dc30954a7326dea7ad52b534a8a6d">start_detached</a> = <a class="el" href="structdi_1_1execution_1_1start__detached__ns_1_1Function.html">start_detached_ns::Function</a> {}</td></tr>
<tr class="memdesc:a346dc30954a7326dea7ad52b534a8a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a sender without waiting for it to complete.  <br /></td></tr>
<tr class="separator:a346dc30954a7326dea7ad52b534a8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3278327cc615b4157fe42c14f2945e2d" id="r_a3278327cc615b4157fe42c14f2945e2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3278327cc615b4157fe42c14f2945e2d">stopped_as_error</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1stopped__as__error__ns_1_1Function.html">stopped_as_error_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:a3278327cc615b4157fe42c14f2945e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc7372601ab39f71efa9807722bc8e" id="r_abcfc7372601ab39f71efa9807722bc8e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfc7372601ab39f71efa9807722bc8e">stopped_as_optional</a> = <a class="el" href="structdi_1_1execution_1_1stopped__as__optional__ns_1_1Function.html">stopped_as_optional_ns::Function</a> {}</td></tr>
<tr class="separator:abcfc7372601ab39f71efa9807722bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade695b89fbe1983c09a3a47d097dcfbb" id="r_ade695b89fbe1983c09a3a47d097dcfbb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade695b89fbe1983c09a3a47d097dcfbb">sync_wait</a> = <a class="el" href="structdi_1_1execution_1_1sync__wait__ns_1_1Function.html">sync_wait_ns::Function</a> {}</td></tr>
<tr class="separator:ade695b89fbe1983c09a3a47d097dcfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb87b87297720f590fb4973e60894d7f" id="r_afb87b87297720f590fb4973e60894d7f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb87b87297720f590fb4973e60894d7f">sync_wait_with_variant</a> = <a class="el" href="structdi_1_1execution_1_1sync__wait__ns_1_1WithVariantFunction.html">sync_wait_ns::WithVariantFunction</a> {}</td></tr>
<tr class="separator:afb87b87297720f590fb4973e60894d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab395b6eab39b5b30a20e18aed59a9765" id="r_ab395b6eab39b5b30a20e18aed59a9765"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab395b6eab39b5b30a20e18aed59a9765">sync_wait_on</a> = <a class="el" href="namespacedi_1_1function.html#af1d3c6e7586b42e06d117953bdb84d02">function::curry</a>(<a class="el" href="structdi_1_1execution_1_1sync__wait__ns_1_1OnFunction.html">sync_wait_ns::OnFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:ab395b6eab39b5b30a20e18aed59a9765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f129b3d1671aecfb288063d90c6ed7" id="r_a65f129b3d1671aecfb288063d90c6ed7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65f129b3d1671aecfb288063d90c6ed7">sync_wait_with_variant_on</a></td></tr>
<tr class="separator:a65f129b3d1671aecfb288063d90c6ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47211a8003b875bddec4f06aa8570ebb" id="r_a47211a8003b875bddec4f06aa8570ebb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47211a8003b875bddec4f06aa8570ebb">then</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__ns_1_1ValueFunction.html">then_ns::ValueFunction</a> {}, c_&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a47211a8003b875bddec4f06aa8570ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sender that maps values into another value.  <br /></td></tr>
<tr class="separator:a47211a8003b875bddec4f06aa8570ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6399cc2f6d400abcbcc4382472dc5411" id="r_a6399cc2f6d400abcbcc4382472dc5411"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6399cc2f6d400abcbcc4382472dc5411">upon_error</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__ns_1_1ErrorFunction.html">then_ns::ErrorFunction</a> {}, c_&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a6399cc2f6d400abcbcc4382472dc5411"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sender that maps an error into a value.  <br /></td></tr>
<tr class="separator:a6399cc2f6d400abcbcc4382472dc5411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc46124e7aa88abda089c2817c72ba" id="r_a05cc46124e7aa88abda089c2817c72ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05cc46124e7aa88abda089c2817c72ba">upon_stopped</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__ns_1_1StoppedFunction.html">then_ns::StoppedFunction</a> {}, c_&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a05cc46124e7aa88abda089c2817c72ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sender that maps the stop signal into a value.  <br /></td></tr>
<tr class="separator:a05cc46124e7aa88abda089c2817c72ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6de8bf32d512d1109632101d864b5d" id="r_a3a6de8bf32d512d1109632101d864b5d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a6de8bf32d512d1109632101d864b5d">transfer</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1transfer__ns_1_1Function.html">transfer_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="separator:a3a6de8bf32d512d1109632101d864b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b99bb9686eb67a9d5bca7a3b9c5738" id="r_a83b99bb9686eb67a9d5bca7a3b9c5738"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83b99bb9686eb67a9d5bca7a3b9c5738">transfer_just</a> = <a class="el" href="structdi_1_1execution_1_1transfer__just__ns_1_1Function.html">transfer_just_ns::Function</a> {}</td></tr>
<tr class="separator:a83b99bb9686eb67a9d5bca7a3b9c5738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453eb71b631652bda317f20dd6aa2142" id="r_a453eb71b631652bda317f20dd6aa2142"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a453eb71b631652bda317f20dd6aa2142">use_resources</a> = <a class="el" href="structdi_1_1execution_1_1use__resources__ns_1_1Function.html">use_resources_ns::Function</a> {}</td></tr>
<tr class="memdesc:a453eb71b631652bda317f20dd6aa2142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use async resources.  <br /></td></tr>
<tr class="separator:a453eb71b631652bda317f20dd6aa2142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4a5552aeddba1c0e1882a482f1ace" id="r_a59d4a5552aeddba1c0e1882a482f1ace"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59d4a5552aeddba1c0e1882a482f1ace">when_all</a> = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1Function.html">when_all_ns::Function</a> {}</td></tr>
<tr class="separator:a59d4a5552aeddba1c0e1882a482f1ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a966b11db02228d1e8d9c002fb9f4" id="r_afc8a966b11db02228d1e8d9c002fb9f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8a966b11db02228d1e8d9c002fb9f4">when_all_with_variant</a> = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1VariantFunction.html">when_all_ns::VariantFunction</a> {}</td></tr>
<tr class="separator:afc8a966b11db02228d1e8d9c002fb9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafecdb3cff7d34407a8440677b59c83a" id="r_aafecdb3cff7d34407a8440677b59c83a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafecdb3cff7d34407a8440677b59c83a">transfer_when_all</a> = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1TransferFunction.html">when_all_ns::TransferFunction</a> {}</td></tr>
<tr class="separator:aafecdb3cff7d34407a8440677b59c83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00043a6029f693e167fe5eabb86096c" id="r_aa00043a6029f693e167fe5eabb86096c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa00043a6029f693e167fe5eabb86096c">transfer_when_all_with_variant</a> = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1TransferVariantFunction.html">when_all_ns::TransferVariantFunction</a> {}</td></tr>
<tr class="separator:aa00043a6029f693e167fe5eabb86096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66465006d06c4717b83e28913ffb4fae" id="r_a66465006d06c4717b83e28913ffb4fae"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66465006d06c4717b83e28913ffb4fae">with_env</a> = <a class="el" href="namespacedi_1_1function.html#af1d3c6e7586b42e06d117953bdb84d02">function::curry</a>(<a class="el" href="structdi_1_1execution_1_1with__env__ns_1_1Function.html">with_env_ns::Function</a> {}, c_&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a66465006d06c4717b83e28913ffb4fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts a sender to run with a specified environment.  <br /></td></tr>
<tr class="separator:a66465006d06c4717b83e28913ffb4fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60221a32614bafb1421eae389a27facd" id="r_a60221a32614bafb1421eae389a27facd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60221a32614bafb1421eae389a27facd">with_debug_env</a> = <a class="el" href="structdi_1_1execution_1_1with__env__ns_1_1DebugFunction.html">with_env_ns::DebugFunction</a> {}</td></tr>
<tr class="memdesc:a60221a32614bafb1421eae389a27facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts a sender to run with a debug environment.  <br /></td></tr>
<tr class="separator:a60221a32614bafb1421eae389a27facd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad321114bb44fb823d3a5219fab053b07" id="r_ad321114bb44fb823d3a5219fab053b07"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structdi_1_1execution_1_1as__awaitable__ns_1_1Function.html">as_awaitable_ns::Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad321114bb44fb823d3a5219fab053b07">as_awaitable</a> = {}</td></tr>
<tr class="separator:ad321114bb44fb823d3a5219fab053b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb81db24d3e8757fd6129c0109dd10" id="r_ab8eb81db24d3e8757fd6129c0109dd10"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8eb81db24d3e8757fd6129c0109dd10">connect</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1ConnectFunction.html">detail::ConnectFunction</a> {}</td></tr>
<tr class="separator:ab8eb81db24d3e8757fd6129c0109dd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5223ed86840b2c660e0f758de770586" id="r_af5223ed86840b2c660e0f758de770586"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:af5223ed86840b2c660e0f758de770586"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5223ed86840b2c660e0f758de770586">enable_sender</a> = requires { typename S::is_sender; }</td></tr>
<tr class="separator:af5223ed86840b2c660e0f758de770586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a73036a389d16438460f568825cdfc" id="r_a78a73036a389d16438460f568825cdfc"><td class="memTemplParams" colspan="2">template&lt;concepts::IsAwaitable&lt; <a class="el" href="structdi_1_1execution_1_1EnvPromise.html">EnvPromise</a>&lt; <a class="el" href="structdi_1_1types_1_1EmptyEnv.html">types::EmptyEnv</a> &gt; &gt; S&gt; </td></tr>
<tr class="memitem:a78a73036a389d16438460f568825cdfc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78a73036a389d16438460f568825cdfc">enable_sender&lt; S &gt;</a> = true</td></tr>
<tr class="separator:a78a73036a389d16438460f568825cdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf39d051bf85db72209739f920fb411e" id="r_aaf39d051bf85db72209739f920fb411e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf39d051bf85db72209739f920fb411e">get_env</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetEnvFunction.html">detail::GetEnvFunction</a> {}</td></tr>
<tr class="separator:aaf39d051bf85db72209739f920fb411e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a85fd1939a6e2c9ac31f1150bcd873" id="r_a28a85fd1939a6e2c9ac31f1150bcd873"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a85fd1939a6e2c9ac31f1150bcd873">run</a> = <a class="el" href="structdi_1_1execution_1_1run__ns_1_1Function.html">run_ns::Function</a> {}</td></tr>
<tr class="memdesc:a28a85fd1939a6e2c9ac31f1150bcd873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain access to an async resource.  <br /></td></tr>
<tr class="separator:a28a85fd1939a6e2c9ac31f1150bcd873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8562510411c44ba43bed9f0eafdac4" id="r_a3b8562510411c44ba43bed9f0eafdac4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b8562510411c44ba43bed9f0eafdac4">schedule</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1ScheduleFunction.html">detail::ScheduleFunction</a> {}</td></tr>
<tr class="separator:a3b8562510411c44ba43bed9f0eafdac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4489f2f3c368ba297e8982d77dd3e27d" id="r_a4489f2f3c368ba297e8982d77dd3e27d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4489f2f3c368ba297e8982d77dd3e27d">start</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1StartFunction.html">detail::StartFunction</a> {}</td></tr>
<tr class="separator:a4489f2f3c368ba297e8982d77dd3e27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf7c3729d1edc3629db34e18cc45d6a" id="r_a6bf7c3729d1edc3629db34e18cc45d6a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bf7c3729d1edc3629db34e18cc45d6a">async_open</a> = <a class="el" href="structdi_1_1execution_1_1async__open__ns_1_1Function.html">async_open_ns::Function</a> {}</td></tr>
<tr class="separator:a6bf7c3729d1edc3629db34e18cc45d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74204c5964851160976290b586a08e2" id="r_ad74204c5964851160976290b586a08e2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad74204c5964851160976290b586a08e2">async_read_exactly</a> = <a class="el" href="structdi_1_1execution_1_1async__read__exactly__ns_1_1Function.html">async_read_exactly_ns::Function</a> {}</td></tr>
<tr class="separator:ad74204c5964851160976290b586a08e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8e3dfd1179f52490ed07c9bc7e2603" id="r_add8e3dfd1179f52490ed07c9bc7e2603"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add8e3dfd1179f52490ed07c9bc7e2603">async_read_some</a> = <a class="el" href="structdi_1_1execution_1_1async__read__some__ns_1_1Function.html">async_read_some_ns::Function</a> {}</td></tr>
<tr class="separator:add8e3dfd1179f52490ed07c9bc7e2603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006515aafcb75f615e286eb10c1555ff" id="r_a006515aafcb75f615e286eb10c1555ff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a006515aafcb75f615e286eb10c1555ff">async_write_exactly</a> = <a class="el" href="structdi_1_1execution_1_1async__write__exactly__ns_1_1Function.html">async_write_exactly_ns::Function</a> {}</td></tr>
<tr class="separator:a006515aafcb75f615e286eb10c1555ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a1ceacc20695a72b405a50d60a5cc2" id="r_ad6a1ceacc20695a72b405a50d60a5cc2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a1ceacc20695a72b405a50d60a5cc2">async_write_some</a> = <a class="el" href="structdi_1_1execution_1_1async__write__some__ns_1_1Function.html">async_write_some_ns::Function</a> {}</td></tr>
<tr class="separator:ad6a1ceacc20695a72b405a50d60a5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386071398ec9c52071a0754c9ca33e5e" id="r_a386071398ec9c52071a0754c9ca33e5e"><td class="memTemplParams" colspan="2">template&lt;concepts::InstanceOf&lt; <a class="el" href="structdi_1_1execution_1_1Protocol.html">Protocol</a> &gt; Proto&gt; </td></tr>
<tr class="memitem:a386071398ec9c52071a0754c9ca33e5e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a386071398ec9c52071a0754c9ca33e5e">ipc_binary_connect_to_client</a> = <a class="el" href="structdi_1_1execution_1_1ipc__binary__ns_1_1ConnectToClientFunction.html">ipc_binary_ns::ConnectToClientFunction</a>&lt;Proto&gt; {}</td></tr>
<tr class="separator:a386071398ec9c52071a0754c9ca33e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542a5d23d60497ba23476a1b8a9238fe" id="r_a542a5d23d60497ba23476a1b8a9238fe"><td class="memTemplParams" colspan="2">template&lt;concepts::InstanceOf&lt; <a class="el" href="structdi_1_1execution_1_1Protocol.html">Protocol</a> &gt; Proto&gt; </td></tr>
<tr class="memitem:a542a5d23d60497ba23476a1b8a9238fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a542a5d23d60497ba23476a1b8a9238fe">ipc_binary_connect_to_server</a> = <a class="el" href="structdi_1_1execution_1_1ipc__binary__ns_1_1ConnectToServerFunction.html">ipc_binary_ns::ConnectToServerFunction</a>&lt;Proto&gt; {}</td></tr>
<tr class="separator:a542a5d23d60497ba23476a1b8a9238fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00ed0a78cc202382fd181e8ed4b824f" id="r_ae00ed0a78cc202382fd181e8ed4b824f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00ed0a78cc202382fd181e8ed4b824f">send</a> = <a class="el" href="structdi_1_1execution_1_1send__ns_1_1Function.html">send_ns::Function</a> {}</td></tr>
<tr class="separator:ae00ed0a78cc202382fd181e8ed4b824f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e1a4201f686c5ce0ecf2b58599b68c" id="r_a67e1a4201f686c5ce0ecf2b58599b68c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67e1a4201f686c5ce0ecf2b58599b68c">forwarding_query</a> = <a class="el" href="structdi_1_1execution_1_1ForwardingQuery.html">ForwardingQuery</a> {}</td></tr>
<tr class="separator:a67e1a4201f686c5ce0ecf2b58599b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71f340d93657c3e3a03c9922fbe4806" id="r_ab71f340d93657c3e3a03c9922fbe4806"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab71f340d93657c3e3a03c9922fbe4806">get_allocator</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetAllocatorFunction.html">detail::GetAllocatorFunction</a> {}</td></tr>
<tr class="separator:ab71f340d93657c3e3a03c9922fbe4806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9308c827420ec17e30bfce196d0c7fb9" id="r_a9308c827420ec17e30bfce196d0c7fb9"><td class="memTemplParams" colspan="2">template&lt;concepts::OneOf&lt; <a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a>, <a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a>, <a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a> &gt; CPO&gt; </td></tr>
<tr class="memitem:a9308c827420ec17e30bfce196d0c7fb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9308c827420ec17e30bfce196d0c7fb9">get_completion_scheduler</a> = <a class="el" href="structdi_1_1execution_1_1GetCompletionScheduler.html">GetCompletionScheduler</a>&lt;CPO&gt; {}</td></tr>
<tr class="separator:a9308c827420ec17e30bfce196d0c7fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d1c95b803c3135bdf3c01ab60dcb82" id="r_ac2d1c95b803c3135bdf3c01ab60dcb82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d1c95b803c3135bdf3c01ab60dcb82">get_completion_signatures</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetCompletionSignaturesFunction.html">detail::GetCompletionSignaturesFunction</a> {}</td></tr>
<tr class="separator:ac2d1c95b803c3135bdf3c01ab60dcb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12919e71dd61e140bbbf3f77d2439b50" id="r_a12919e71dd61e140bbbf3f77d2439b50"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12919e71dd61e140bbbf3f77d2439b50">get_delegatee_scheduler</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetDelegateeSchedulerFunction.html">detail::GetDelegateeSchedulerFunction</a> {}</td></tr>
<tr class="separator:a12919e71dd61e140bbbf3f77d2439b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378370171b93f20995a46c35fe327a58" id="r_a378370171b93f20995a46c35fe327a58"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a378370171b93f20995a46c35fe327a58">get_forward_progress_guarantee</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetForwardProgressGuaranteeFunction.html">detail::GetForwardProgressGuaranteeFunction</a> {}</td></tr>
<tr class="separator:a378370171b93f20995a46c35fe327a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab2d2447a0b5dfab6fb4ec912a51f1b" id="r_a9ab2d2447a0b5dfab6fb4ec912a51f1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab2d2447a0b5dfab6fb4ec912a51f1b">get_scheduler</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetSchedulerFunction.html">detail::GetSchedulerFunction</a> {}</td></tr>
<tr class="separator:a9ab2d2447a0b5dfab6fb4ec912a51f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819fdd458add93fac4e126bb5e9ebfa1" id="r_a819fdd458add93fac4e126bb5e9ebfa1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819fdd458add93fac4e126bb5e9ebfa1">get_sequence_cardinality</a> = <a class="el" href="structdi_1_1execution_1_1get__sequence__cardinality__ns_1_1Function.html">get_sequence_cardinality_ns::Function</a> {}</td></tr>
<tr class="memdesc:a819fdd458add93fac4e126bb5e9ebfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that returns the cardinality of a sequence.  <br /></td></tr>
<tr class="separator:a819fdd458add93fac4e126bb5e9ebfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33cf422a56fd4e70b6a5299349533b9" id="r_aa33cf422a56fd4e70b6a5299349533b9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa33cf422a56fd4e70b6a5299349533b9">get_stop_token</a> = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetStopTokenFunction.html">detail::GetStopTokenFunction</a> {}</td></tr>
<tr class="separator:aa33cf422a56fd4e70b6a5299349533b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9901c7da667aac8d8b16c542cce6a708" id="r_a9901c7da667aac8d8b16c542cce6a708"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9901c7da667aac8d8b16c542cce6a708">is_always_lockstep_sequence</a> = <a class="el" href="structdi_1_1execution_1_1is__always__lockstop__sequence__ns_1_1Function.html">is_always_lockstop_sequence_ns::Function</a> {}</td></tr>
<tr class="memdesc:a9901c7da667aac8d8b16c542cce6a708"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that returns whether or not a sequence is always lockstep.  <br /></td></tr>
<tr class="separator:a9901c7da667aac8d8b16c542cce6a708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae286b4db803b2d352cb9b5568a25da0a" id="r_ae286b4db803b2d352cb9b5568a25da0a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae286b4db803b2d352cb9b5568a25da0a">is_debug_env</a> = <a class="el" href="structdi_1_1execution_1_1is__debug__env__ns_1_1Function.html">is_debug_env_ns::Function</a> {}</td></tr>
<tr class="memdesc:ae286b4db803b2d352cb9b5568a25da0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given environment is a debug environment.  <br /></td></tr>
<tr class="separator:ae286b4db803b2d352cb9b5568a25da0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885402d0ef97e17547751e4949ee96cc" id="r_a885402d0ef97e17547751e4949ee96cc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a885402d0ef97e17547751e4949ee96cc">with</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1WithFunction.html">make_env_ns::WithFunction</a> {}</td></tr>
<tr class="memdesc:a885402d0ef97e17547751e4949ee96cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an override for an environment query.  <br /></td></tr>
<tr class="separator:a885402d0ef97e17547751e4949ee96cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1309fd4bdf38e54cb705408875651040" id="r_a1309fd4bdf38e54cb705408875651040"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1309fd4bdf38e54cb705408875651040">without</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1WithoutFunction.html">make_env_ns::WithoutFunction</a> {}</td></tr>
<tr class="memdesc:a1309fd4bdf38e54cb705408875651040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a removal of an environment query override.  <br /></td></tr>
<tr class="separator:a1309fd4bdf38e54cb705408875651040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59274784714d063ff3e706df9ad50e9c" id="r_a59274784714d063ff3e706df9ad50e9c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59274784714d063ff3e706df9ad50e9c">make_env</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1Function.html">make_env_ns::Function</a> {}</td></tr>
<tr class="memdesc:a59274784714d063ff3e706df9ad50e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an environment with overrides for queries.  <br /></td></tr>
<tr class="separator:a59274784714d063ff3e706df9ad50e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b7f6b97142e5318a0231f1913c343c" id="r_ac0b7f6b97142e5318a0231f1913c343c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ac0b7f6b97142e5318a0231f1913c343c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0b7f6b97142e5318a0231f1913c343c">enable_receiver</a> = requires { typename R::is_receiver; }</td></tr>
<tr class="separator:ac0b7f6b97142e5318a0231f1913c343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb1fba8e927043ba1e97e786af5b6f" id="r_a0feb1fba8e927043ba1e97e786af5b6f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0feb1fba8e927043ba1e97e786af5b6f">set_error</a> = <a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a> {}</td></tr>
<tr class="separator:a0feb1fba8e927043ba1e97e786af5b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8f3c564f58980589101202f543b7d0" id="r_a7b8f3c564f58980589101202f543b7d0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b8f3c564f58980589101202f543b7d0">set_stopped</a> = <a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a> {}</td></tr>
<tr class="separator:a7b8f3c564f58980589101202f543b7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4325f4d43b09dc0cd01e9b559ce1c11" id="r_ad4325f4d43b09dc0cd01e9b559ce1c11"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4325f4d43b09dc0cd01e9b559ce1c11">set_value</a> = <a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a> {}</td></tr>
<tr class="separator:ad4325f4d43b09dc0cd01e9b559ce1c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc6e885f72c4370ad160b678466bab6" id="r_a5fc6e885f72c4370ad160b678466bab6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fc6e885f72c4370ad160b678466bab6">request_stop</a> = <a class="el" href="structdi_1_1execution_1_1request__stop__ns_1_1Function.html">request_stop_ns::Function</a> {}</td></tr>
<tr class="memdesc:a5fc6e885f72c4370ad160b678466bab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that a scope stop.  <br /></td></tr>
<tr class="separator:a5fc6e885f72c4370ad160b678466bab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79c57f100fce9f000b54d4b5d4db498" id="r_ac79c57f100fce9f000b54d4b5d4db498"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498">nest</a> = <a class="el" href="structdi_1_1execution_1_1nest__ns_1_1Function.html">nest_ns::Function</a> {}</td></tr>
<tr class="memdesc:ac79c57f100fce9f000b54d4b5d4db498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nest a sender inside a scope.  <br /></td></tr>
<tr class="separator:ac79c57f100fce9f000b54d4b5d4db498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbdc8590257091c72345c9d73fdd262" id="r_a2cbdc8590257091c72345c9d73fdd262"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cbdc8590257091c72345c9d73fdd262">spawn</a> = <a class="el" href="structdi_1_1execution_1_1spawn__ns_1_1Function.html">spawn_ns::Function</a> {}</td></tr>
<tr class="memdesc:a2cbdc8590257091c72345c9d73fdd262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a sender inside a scope.  <br /></td></tr>
<tr class="separator:a2cbdc8590257091c72345c9d73fdd262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f91f698e51a9c7a9479c769e7aa69b3" id="r_a9f91f698e51a9c7a9479c769e7aa69b3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3">spawn_future</a> = <a class="el" href="structdi_1_1execution_1_1spawn__future__ns_1_1Function.html">spawn_future_ns::Function</a> {}</td></tr>
<tr class="memdesc:a9f91f698e51a9c7a9479c769e7aa69b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a sender inside a scope, and return a future to the result.  <br /></td></tr>
<tr class="separator:a9f91f698e51a9c7a9479c769e7aa69b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ba685c3f5ce640b74e033026c51840" id="r_a97ba685c3f5ce640b74e033026c51840"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ba685c3f5ce640b74e033026c51840">next</a> = <a class="el" href="structdi_1_1execution_1_1next__ns_1_1Function.html">next_ns::Function</a> {}</td></tr>
<tr class="memdesc:a97ba685c3f5ce640b74e033026c51840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next value of a async range in a coroutine.  <br /></td></tr>
<tr class="separator:a97ba685c3f5ce640b74e033026c51840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804bd611b2f8306950d2fc12af273f4" id="r_a3804bd611b2f8306950d2fc12af273f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3804bd611b2f8306950d2fc12af273f4">empty_sequence</a> = <a class="el" href="structdi_1_1execution_1_1empty__sequence__ns_1_1Function.html">empty_sequence_ns::Function</a> {}</td></tr>
<tr class="memdesc:a3804bd611b2f8306950d2fc12af273f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence sender that completes immediately without ever sending a value.  <br /></td></tr>
<tr class="separator:a3804bd611b2f8306950d2fc12af273f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e467f0beb1fff9106b8f27b5eade19" id="r_a62e467f0beb1fff9106b8f27b5eade19"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62e467f0beb1fff9106b8f27b5eade19">filter</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1filter__ns_1_1Function.html">filter_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a62e467f0beb1fff9106b8f27b5eade19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter the values of a sequence.  <br /></td></tr>
<tr class="separator:a62e467f0beb1fff9106b8f27b5eade19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c87368345e68d8b7342e32cd3b469a" id="r_a44c87368345e68d8b7342e32cd3b469a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c87368345e68d8b7342e32cd3b469a">first_value</a> = <a class="el" href="structdi_1_1execution_1_1first__value__ns_1_1Function.html">first_value_ns::Function</a> {}</td></tr>
<tr class="memdesc:a44c87368345e68d8b7342e32cd3b469a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a sequence into a sender of its first value.  <br /></td></tr>
<tr class="separator:a44c87368345e68d8b7342e32cd3b469a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6608d87dcbac3f44f01bdd66fa1ffe8f" id="r_a6608d87dcbac3f44f01bdd66fa1ffe8f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6608d87dcbac3f44f01bdd66fa1ffe8f">valid_lifetime</a> = <a class="el" href="structdi_1_1execution_1_1from__container__ns_1_1ValidLifetimeTag.html">from_container_ns::ValidLifetimeTag</a> {}</td></tr>
<tr class="memdesc:a6608d87dcbac3f44f01bdd66fa1ffe8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to indicate that the container lifetime is valid for the async sequence.  <br /></td></tr>
<tr class="separator:a6608d87dcbac3f44f01bdd66fa1ffe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0a3a801099bc8209937d00ed569421" id="r_a3f0a3a801099bc8209937d00ed569421"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f0a3a801099bc8209937d00ed569421">from_container</a> = <a class="el" href="structdi_1_1execution_1_1from__container__ns_1_1Function.html">from_container_ns::Function</a> {}</td></tr>
<tr class="memdesc:a3f0a3a801099bc8209937d00ed569421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sequence sender from a container.  <br /></td></tr>
<tr class="separator:a3f0a3a801099bc8209937d00ed569421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161d61fb3d9e428677872b18a4298ef0" id="r_a161d61fb3d9e428677872b18a4298ef0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a161d61fb3d9e428677872b18a4298ef0">ignore_all</a> = <a class="el" href="structdi_1_1execution_1_1ignore__all__ns_1_1Function.html">ignore_all_ns::Function</a> {}</td></tr>
<tr class="memdesc:a161d61fb3d9e428677872b18a4298ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a sequence sender to a regular sender of void, ignoring the sequence's values.  <br /></td></tr>
<tr class="separator:a161d61fb3d9e428677872b18a4298ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab707edaa7183d9de7470e063158164a" id="r_aab707edaa7183d9de7470e063158164a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab707edaa7183d9de7470e063158164a">into_lockstep_sequence</a> = <a class="el" href="structdi_1_1execution_1_1into__lockstep__sequence__ns_1_1Function.html">into_lockstep_sequence_ns::Function</a> {}</td></tr>
<tr class="memdesc:aab707edaa7183d9de7470e063158164a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a sequence into a lockstep sequence.  <br /></td></tr>
<tr class="separator:aab707edaa7183d9de7470e063158164a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2657238be4f5696647e228e7ab49a996" id="r_a2657238be4f5696647e228e7ab49a996"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2657238be4f5696647e228e7ab49a996">into_variant_each</a> = <a class="el" href="structdi_1_1execution_1_1into__variant__each__ns_1_1Function.html">into_variant_each_ns::Function</a> {}</td></tr>
<tr class="memdesc:a2657238be4f5696647e228e7ab49a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the values of a sequence into a variant.  <br /></td></tr>
<tr class="separator:a2657238be4f5696647e228e7ab49a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d3aaea880b0a40fcdb5c5e0c72592d" id="r_a90d3aaea880b0a40fcdb5c5e0c72592d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90d3aaea880b0a40fcdb5c5e0c72592d">let_value_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__each__ns_1_1ValueFunction.html">let_each_ns::ValueFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a90d3aaea880b0a40fcdb5c5e0c72592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the values of a sequence into new senders.  <br /></td></tr>
<tr class="separator:a90d3aaea880b0a40fcdb5c5e0c72592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69751d56705808577e80f2df326f1b53" id="r_a69751d56705808577e80f2df326f1b53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69751d56705808577e80f2df326f1b53">let_error_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__each__ns_1_1ErrorFunction.html">let_each_ns::ErrorFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a69751d56705808577e80f2df326f1b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the errors of a sequence into new senders.  <br /></td></tr>
<tr class="separator:a69751d56705808577e80f2df326f1b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945976c474bee70741a2daf4a80b1abd" id="r_a945976c474bee70741a2daf4a80b1abd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945976c474bee70741a2daf4a80b1abd">let_stopped_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__each__ns_1_1StoppedFunction.html">let_each_ns::StoppedFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a945976c474bee70741a2daf4a80b1abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the stopped signal of a sequence into new senders.  <br /></td></tr>
<tr class="separator:a945976c474bee70741a2daf4a80b1abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b209d4eb75ee4d6bf75424453f35e8f" id="r_a3b209d4eb75ee4d6bf75424453f35e8f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b209d4eb75ee4d6bf75424453f35e8f">repeat</a> = <a class="el" href="structdi_1_1execution_1_1repeat__ns_1_1Function.html">repeat_ns::Function</a> {}</td></tr>
<tr class="memdesc:a3b209d4eb75ee4d6bf75424453f35e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a copyable sender into an infinite sequence sender.  <br /></td></tr>
<tr class="separator:a3b209d4eb75ee4d6bf75424453f35e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2458c1749fcf4c3a9fe48a55ab8820ba" id="r_a2458c1749fcf4c3a9fe48a55ab8820ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2458c1749fcf4c3a9fe48a55ab8820ba">set_next</a> = <a class="el" href="structdi_1_1execution_1_1set__next__ns_1_1Function.html">set_next_ns::Function</a> {}</td></tr>
<tr class="memdesc:a2458c1749fcf4c3a9fe48a55ab8820ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the next sender of a sequence.  <br /></td></tr>
<tr class="separator:a2458c1749fcf4c3a9fe48a55ab8820ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e5885549fd5b1a99e397e3f21217dc" id="r_a11e5885549fd5b1a99e397e3f21217dc"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a11e5885549fd5b1a99e397e3f21217dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11e5885549fd5b1a99e397e3f21217dc">enable_sequence_sender</a> = false</td></tr>
<tr class="separator:a11e5885549fd5b1a99e397e3f21217dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e00afc6df733f05f17c4930613b84cb" id="r_a1e00afc6df733f05f17c4930613b84cb"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; <br />
requires (concepts::AwaitableAsyncRange&lt;S&gt;)</td></tr>
<tr class="memitem:a1e00afc6df733f05f17c4930613b84cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e00afc6df733f05f17c4930613b84cb">enable_sequence_sender&lt; S &gt;</a> = true</td></tr>
<tr class="separator:a1e00afc6df733f05f17c4930613b84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b77b087d9dba9eef4d2b9d8edf17a6f" id="r_a8b77b087d9dba9eef4d2b9d8edf17a6f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b77b087d9dba9eef4d2b9d8edf17a6f">subscribe</a> = <a class="el" href="structdi_1_1execution_1_1subscribe__ns_1_1Function.html">subscribe_ns::Function</a> {}</td></tr>
<tr class="memdesc:a8b77b087d9dba9eef4d2b9d8edf17a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a receiver to a sequence.  <br /></td></tr>
<tr class="separator:a8b77b087d9dba9eef4d2b9d8edf17a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2dfb9dbd067eec2c5750ca3006c2b8" id="r_aeb2dfb9dbd067eec2c5750ca3006c2b8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb2dfb9dbd067eec2c5750ca3006c2b8">then_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__each__ns_1_1Function.html">then_each_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:aeb2dfb9dbd067eec2c5750ca3006c2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the values of a sequence directly.  <br /></td></tr>
<tr class="separator:aeb2dfb9dbd067eec2c5750ca3006c2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550e6db854b2100fd29de808b36fa00f" id="r_a550e6db854b2100fd29de808b36fa00f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a550e6db854b2100fd29de808b36fa00f">upon_error_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__each__ns_1_1ErrorFunction.html">then_each_ns::ErrorFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a550e6db854b2100fd29de808b36fa00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the errors of a sequence directly.  <br /></td></tr>
<tr class="separator:a550e6db854b2100fd29de808b36fa00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069327ec13983f51238939454b13b411" id="r_a069327ec13983f51238939454b13b411"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a069327ec13983f51238939454b13b411">upon_stopped_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__each__ns_1_1StoppedFunction.html">then_each_ns::StoppedFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a069327ec13983f51238939454b13b411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform stopped values of a sequence directly.  <br /></td></tr>
<tr class="separator:a069327ec13983f51238939454b13b411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9a7f408586ff517531ce1b7daf9fab" id="r_a8f9a7f408586ff517531ce1b7daf9fab"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab">transform_each</a> = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1transform__each__ns_1_1Function.html">transform_each_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td></tr>
<tr class="memdesc:a8f9a7f408586ff517531ce1b7daf9fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform each sender of a sequence.  <br /></td></tr>
<tr class="separator:a8f9a7f408586ff517531ce1b7daf9fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70a9cea178eec6ca25e6163042fea06" id="r_ad70a9cea178eec6ca25e6163042fea06"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad70a9cea178eec6ca25e6163042fea06">zip</a> = <a class="el" href="structdi_1_1execution_1_1zip__ns_1_1Function.html">zip_ns::Function</a> {}</td></tr>
<tr class="memdesc:ad70a9cea178eec6ca25e6163042fea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip multiple sequences together.  <br /></td></tr>
<tr class="separator:ad70a9cea178eec6ca25e6163042fea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8be53f60722f84d102c011699172ac" id="r_acc8be53f60722f84d102c011699172ac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8be53f60722f84d102c011699172ac">zip_with_variant</a> = <a class="el" href="structdi_1_1execution_1_1zip__ns_1_1VariantFunction.html">zip_ns::VariantFunction</a> {}</td></tr>
<tr class="memdesc:acc8be53f60722f84d102c011699172ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip multiple sequences together, allowing them to send different types of values.  <br /></td></tr>
<tr class="separator:acc8be53f60722f84d102c011699172ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a140f587339eadd05e451ea025554b638" name="a140f587339eadd05e451ea025554b638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140f587339eadd05e451ea025554b638">&#9670;&#160;</a></span>AnyOperationState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Env  = void, concepts::AnyStorage Storage = any::HybridStorage&lt;any::StorageCategory::MoveOnly, 8 * sizeof(void*), alignof(void*)&gt;, typename VTablePolicy  = any::MaybeInlineVTable&lt;3&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a140f587339eadd05e451ea025554b638">di::execution::AnyOperationState</a> = Any&lt;<a class="el" href="#abfc6f39a4e48ca67d9020f7837f6ec08">InterfaceWithEnv</a>&lt;<a class="el" href="structdi_1_1meta_1_1List.html">meta::List</a>&lt;<a class="el" href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">types::Tag</a>&lt;<a class="el" href="#a4489f2f3c368ba297e8982d77dd3e27d">execution::start</a>&gt;&gt;, Env&gt;, Storage, VTablePolicy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9fc7858870e05c42481fac582dcedeb" name="af9fc7858870e05c42481fac582dcedeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fc7858870e05c42481fac582dcedeb">&#9670;&#160;</a></span>AnyReceiver</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::ValidCompletionSignatures Sigs, typename Env  = void, concepts::AnyStorage Storage = any::InlineStorage&lt;2 * sizeof(void*), alignof(void*)&gt;, typename VTablePolicy  = any::MaybeInlineVTable&lt;3&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af9fc7858870e05c42481fac582dcedeb">di::execution::AnyReceiver</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1AnyReceiverT.html">AnyReceiverT</a>&lt;Sigs, Env, Storage, VTablePolicy&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a098f6c0b5170bad93bef48f2942c67c6" name="a098f6c0b5170bad93bef48f2942c67c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098f6c0b5170bad93bef48f2942c67c6">&#9670;&#160;</a></span>AnySender</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::ValidCompletionSignatures Sigs, typename Env  = void, concepts::AnyStorage Storage = any::HybridStorage&lt;&gt;, typename VTablePolicy  = any::MaybeInlineVTable&lt;3&gt;, concepts::OperationState Op = AnyOperationState&lt;&gt;, typename Rec  = AnyReceiver&lt;detail::AnySigs&lt;Sigs&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a098f6c0b5170bad93bef48f2942c67c6">di::execution::AnySender</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1AnySenderT.html">AnySenderT</a>&lt;Sigs, Env, Storage, VTablePolicy, Op, Rec&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b3d18b9a4deba93f4bfa582edc376b" name="ad4b3d18b9a4deba93f4bfa582edc376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b3d18b9a4deba93f4bfa582edc376b">&#9670;&#160;</a></span>AnySenderOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad4b3d18b9a4deba93f4bfa582edc376b">di::execution::AnySenderOf</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1AnySenderOfT.html">AnySenderOfT</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a765a5e7168d2f4aded33132da901aadb" name="a765a5e7168d2f4aded33132da901aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765a5e7168d2f4aded33132da901aadb">&#9670;&#160;</a></span>AsyncGenerator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ref , typename Value  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a765a5e7168d2f4aded33132da901aadb">di::execution::AsyncGenerator</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1async__generator__ns_1_1AsyncGeneratorT.html">async_generator_ns::AsyncGeneratorT</a>&lt;Ref, Value&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4da9ade646e9b5e956bb30a00fccff27" name="a4da9ade646e9b5e956bb30a00fccff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da9ade646e9b5e956bb30a00fccff27">&#9670;&#160;</a></span>CountingScope</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::Allocator Alloc = platform::DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4da9ade646e9b5e956bb30a00fccff27">di::execution::CountingScope</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1counting__scope__ns_1_1CountingScopeT.html">counting_scope_ns::CountingScopeT</a>&lt;Alloc&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A scope that waits for all spawned senders to complete. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Alloc</td><td>The allocator to use for the scope.</td></tr>
  </table>
  </dd>
</dl>
<p>CountingScope is a scope that waits for all spawned senders to complete, using the async resource mechanism. This means that it can only be accessed using the <a class="el" href="#a453eb71b631652bda317f20dd6aa2142" title="Use async resources.">execution::use_resources</a> function. The provided token allows spawning work, and the async "destructor" will wait for all spawned work to complete.</p>
<p>This limited API allows the scope to be implemented efficently, with only an atomic counter. This is possible only because the resource API guarantees that we will wait for all spawned work exactly once. More advanced use cases may need to wait multiple times, or store the scope in non-async storage, and would need to use a different scope implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a453eb71b631652bda317f20dd6aa2142" title="Use async resources.">use_resources</a> </dd>
<dd>
<a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">nest</a> </dd>
<dd>
<a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">spawn</a> </dd>
<dd>
<a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">spawn_future</a> </dd>
<dd>
<a class="el" href="#a5fc6e885f72c4370ad160b678466bab6" title="Request that a scope stop.">request_stop</a> </dd></dl>

</div>
</div>
<a id="abfc6f39a4e48ca67d9020f7837f6ec08" name="abfc6f39a4e48ca67d9020f7837f6ec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc6f39a4e48ca67d9020f7837f6ec08">&#9670;&#160;</a></span>InterfaceWithEnv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::Interface Interface, typename Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abfc6f39a4e48ca67d9020f7837f6ec08">di::execution::InterfaceWithEnv</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> meta::Conditional&lt;</div>
<div class="line">    <a class="code hl_concept" href="conceptdi_1_1concepts_1_1LanguageVoid.html">concepts::LanguageVoid&lt;Env&gt;</a>, Interface,</div>
<div class="line">    meta::MergeInterfaces&lt;Interface,</div>
<div class="line">                          meta::List&lt;types::Method&lt;types::Tag&lt;execution::get_env&gt;, Env(types::This <span class="keyword">const</span>&amp;)&gt;&gt;&gt;&gt;</div>
<div class="ttc" id="aconceptdi_1_1concepts_1_1LanguageVoid_html"><div class="ttname"><a href="conceptdi_1_1concepts_1_1LanguageVoid.html">di::concepts::LanguageVoid</a></div><div class="ttdef"><b>Definition</b> core.h:128</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa97dc746831b601122b2fa9a60356aa4" name="aa97dc746831b601122b2fa9a60356aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97dc746831b601122b2fa9a60356aa4">&#9670;&#160;</a></span>MakeEnv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseEnv , typename... Withs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa97dc746831b601122b2fa9a60356aa4">di::execution::MakeEnv</a> = decltype(<a class="el" href="#a59274784714d063ff3e706df9ad50e9c">make_env</a>(<a class="el" href="namespacedi_1_1util.html#adabf7c526a3f93dfe8d610923a1579a9">util::declval</a>&lt;BaseEnv&gt;(), <a class="el" href="namespacedi_1_1util.html#adabf7c526a3f93dfe8d610923a1579a9">util::declval</a>&lt;Withs&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represent an environment with overrides for queries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BaseEnv</td><td>The base environment to use for forwarding queries that are not overridden. </td></tr>
    <tr><td class="paramname">Withs</td><td>The overrides to use for queries.</td></tr>
  </table>
  </dd>
</dl>
<p>This template is used to deduce the return type of the <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function. This is used by sender algorithms which customize the environment to properly query a sender's completion signatures, which vary based on the environment they are invoked in.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">make_env</a> </dd>
<dd>
<a class="el" href="#a885402d0ef97e17547751e4949ee96cc" title="Specify an override for an environment query.">with</a> </dd>
<dd>
<a class="el" href="#a989f3f0c1225b688e96d0b2d239fbb45" title="Represent a override for an environment query.">With</a> </dd></dl>

</div>
</div>
<a id="a7a9910ac14eb1ff31dadbc731a662e76" name="a7a9910ac14eb1ff31dadbc731a662e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9910ac14eb1ff31dadbc731a662e76">&#9670;&#160;</a></span>ReceiverAdaptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::ClassType Self, concepts::Receiver Base = receiver_interface_ns::fake_receiver::FakeReceiver&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7a9910ac14eb1ff31dadbc731a662e76">di::execution::ReceiverAdaptor</a> = <a class="el" href="namespacedi_1_1meta.html#a2c3657c318cf71237fe5818f46ae23a4">meta::Type</a>&lt;<a class="el" href="structdi_1_1execution_1_1receiver__interface__ns_1_1ReceiverAdaptor.html">receiver_interface_ns::ReceiverAdaptor</a>&lt;Self, Base&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26e4d17bd7f053f793177316211c2bb8" name="a26e4d17bd7f053f793177316211c2bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e4d17bd7f053f793177316211c2bb8">&#9670;&#160;</a></span>Stopped</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a26e4d17bd7f053f793177316211c2bb8">di::execution::Stopped</a> = decltype(<a class="el" href="#ad5dfbc3a12da3fdb5f57e8117230de9f">just_stopped</a>())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a989f3f0c1225b688e96d0b2d239fbb45" name="a989f3f0c1225b688e96d0b2d239fbb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989f3f0c1225b688e96d0b2d239fbb45">&#9670;&#160;</a></span>With</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Val &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a989f3f0c1225b688e96d0b2d239fbb45">di::execution::With</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1With.html">make_env_ns::With</a>&lt;Tag, Val&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represent a override for an environment query. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>The tag of the query to override. </td></tr>
    <tr><td class="paramname">Val</td><td>The value to use for the override.</td></tr>
  </table>
  </dd>
</dl>
<p>This type is used as a parameter to <code><a class="el" href="#aa97dc746831b601122b2fa9a60356aa4" title="Represent an environment with overrides for queries.">execution::MakeEnv</a></code> template to specify an override for a query. This is useful to deduce the return type of the <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">make_env</a> </dd>
<dd>
<a class="el" href="#a885402d0ef97e17547751e4949ee96cc" title="Specify an override for an environment query.">with</a> </dd>
<dd>
<a class="el" href="#aa97dc746831b601122b2fa9a60356aa4" title="Represent an environment with overrides for queries.">MakeEnv</a> </dd></dl>

</div>
</div>
<a id="a6b90e8571ceb6ef63751a2bcaccc83ec" name="a6b90e8571ceb6ef63751a2bcaccc83ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b90e8571ceb6ef63751a2bcaccc83ec">&#9670;&#160;</a></span>Without</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6b90e8571ceb6ef63751a2bcaccc83ec">di::execution::Without</a> = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1Without.html">make_env_ns::Without</a>&lt;Tag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represent a removal of an environment query value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>The tag of the query to remove the override for.</td></tr>
  </table>
  </dd>
</dl>
<p>This type is used as a parameter to <code><a class="el" href="#aa97dc746831b601122b2fa9a60356aa4" title="Represent an environment with overrides for queries.">execution::MakeEnv</a></code> template to specify a removal of an existing environment value. This is useful to deduce the return type of the <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">make_env</a> </dd>
<dd>
<a class="el" href="#a885402d0ef97e17547751e4949ee96cc" title="Specify an override for an environment query.">with</a> </dd>
<dd>
<a class="el" href="#aa97dc746831b601122b2fa9a60356aa4" title="Represent an environment with overrides for queries.">MakeEnv</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1bf5633424c5fd8590c971cdb26aee22" name="a1bf5633424c5fd8590c971cdb26aee22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf5633424c5fd8590c971cdb26aee22">&#9670;&#160;</a></span>ForwardProgressGuarantee</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1bf5633424c5fd8590c971cdb26aee22">di::execution::ForwardProgressGuarantee</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1bf5633424c5fd8590c971cdb26aee22a3aee746018287558354fbcd7dd8bb904" name="a1bf5633424c5fd8590c971cdb26aee22a3aee746018287558354fbcd7dd8bb904"></a>Concurrent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1bf5633424c5fd8590c971cdb26aee22a98402eecfbcefc336954458a01752131" name="a1bf5633424c5fd8590c971cdb26aee22a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1bf5633424c5fd8590c971cdb26aee22a066bf4627e8236d8533e7001aaa8c228" name="a1bf5633424c5fd8590c971cdb26aee22a066bf4627e8236d8533e7001aaa8c228"></a>WeaklyParallel&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad321114bb44fb823d3a5219fab053b07" name="ad321114bb44fb823d3a5219fab053b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad321114bb44fb823d3a5219fab053b07">&#9670;&#160;</a></span>as_awaitable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdi_1_1execution_1_1as__awaitable__ns_1_1Function.html">as_awaitable_ns::Function</a> const di::execution::as_awaitable = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bf7c3729d1edc3629db34e18cc45d6a" name="a6bf7c3729d1edc3629db34e18cc45d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf7c3729d1edc3629db34e18cc45d6a">&#9670;&#160;</a></span>async_open</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::async_open = <a class="el" href="structdi_1_1execution_1_1async__open__ns_1_1Function.html">async_open_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad74204c5964851160976290b586a08e2" name="ad74204c5964851160976290b586a08e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74204c5964851160976290b586a08e2">&#9670;&#160;</a></span>async_read_exactly</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::async_read_exactly = <a class="el" href="structdi_1_1execution_1_1async__read__exactly__ns_1_1Function.html">async_read_exactly_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add8e3dfd1179f52490ed07c9bc7e2603" name="add8e3dfd1179f52490ed07c9bc7e2603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8e3dfd1179f52490ed07c9bc7e2603">&#9670;&#160;</a></span>async_read_some</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::async_read_some = <a class="el" href="structdi_1_1execution_1_1async__read__some__ns_1_1Function.html">async_read_some_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a006515aafcb75f615e286eb10c1555ff" name="a006515aafcb75f615e286eb10c1555ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006515aafcb75f615e286eb10c1555ff">&#9670;&#160;</a></span>async_write_exactly</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::async_write_exactly = <a class="el" href="structdi_1_1execution_1_1async__write__exactly__ns_1_1Function.html">async_write_exactly_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6a1ceacc20695a72b405a50d60a5cc2" name="ad6a1ceacc20695a72b405a50d60a5cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a1ceacc20695a72b405a50d60a5cc2">&#9670;&#160;</a></span>async_write_some</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::async_write_some = <a class="el" href="structdi_1_1execution_1_1async__write__some__ns_1_1Function.html">async_write_some_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69b45f0c066c4f960ee10a8e6502fbac" name="a69b45f0c066c4f960ee10a8e6502fbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b45f0c066c4f960ee10a8e6502fbac">&#9670;&#160;</a></span>bulk</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::bulk = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1bulk__ns_1_1Function.html">bulk_ns::Function</a> {}, c_&lt;3zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bulk apply a function to a range of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to send values from. </td></tr>
    <tr><td class="paramname">shape</td><td>The number of values to send. </td></tr>
    <tr><td class="paramname">function</td><td>The function to apply to each value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that applies the function to each value and sends the original values through unchanged.</dd></dl>
<p>This function is similar to <a class="el" href="namespacedi_1_1container.html#a5e25a2109ba54e93ceba60dd0fbfce63">container::for_each</a> except that it is applied for every index in the specified shape. The adapted sender will send the original values through unchanged, unless the function returns an error, in which case the returned sender will send the error to the receiver.</p>
<p>On schedulers which support parallel execution, the scheduler should customize <a class="el" href="#a69b45f0c066c4f960ee10a8e6502fbac" title="Bulk apply a function to a range of values.">execution::bulk</a>, which enables the function to be applied in parallel.</p>
<p>The following example demonstrates how to sum over a vector of values in parallel, using a vector of intemediate results to avoid contention. </p><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedi_1_1execution.html">execution</a> = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// NOTE: this could be a thread-pool scheduler instead.</span></div>
<div class="line">    <span class="keyword">auto</span> scheduler = <a class="code hl_struct" href="structdi_1_1execution_1_1InlineScheduler.html">execution::InlineScheduler</a> {};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> usize count = 1000;</div>
<div class="line">    <span class="keyword">constexpr</span> usize tile_count = 10;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>CachelinePadded {</div>
<div class="line">        <span class="keyword">alignas</span>(128) usize value;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> numbers = di::range(count) | di::to&lt;di::Vector&gt;();</div>
<div class="line">    <span class="keyword">auto</span> partials = di::repeat(CachelinePadded(0)) | di::take(tile_count) | di::to&lt;di::Vector&gt;();</div>
<div class="line">    <span class="keyword">auto</span> work = <a class="code hl_variable" href="#a83b99bb9686eb67a9d5bca7a3b9c5738">execution::transfer_just</a>(scheduler, di::move(numbers), di::move(partials)) |</div>
<div class="line">                <a class="code hl_variable" href="#a69b45f0c066c4f960ee10a8e6502fbac">execution::bulk</a>(tile_count,</div>
<div class="line">                                [](usize i, di::Vector&lt;usize&gt;&amp; numbers, di::Vector&lt;CachelinePadded&gt;&amp; partials) {</div>
<div class="line">                                    <span class="keyword">auto</span> <a class="code hl_variable" href="#a4489f2f3c368ba297e8982d77dd3e27d">start</a> = i * (numbers.size() / tile_count);</div>
<div class="line">                                    <span class="keyword">auto</span> end = di::min((i + 1) * (numbers.size() / tile_count), numbers.size());</div>
<div class="line">                                    partials[i].value = di::sum(numbers | di::drop(start) | di::take(end - start));</div>
<div class="line">                                }) |</div>
<div class="line">                <a class="code hl_variable" href="#a47211a8003b875bddec4f06aa8570ebb">execution::then</a>([](di::Vector&lt;usize&gt;, di::Vector&lt;CachelinePadded&gt; partials) {</div>
<div class="line">                    <span class="keywordflow">return</span> di::sum(partials | di::transform(&amp;CachelinePadded::value));</div>
<div class="line">                });</div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(di::move(work)), count * (count - 1) / 2);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The function must be thread-safe, if invoked on a parallel scheduler. </dd></dl>

</div>
</div>
<a id="ab8eb81db24d3e8757fd6129c0109dd10" name="ab8eb81db24d3e8757fd6129c0109dd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8eb81db24d3e8757fd6129c0109dd10">&#9670;&#160;</a></span>connect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::connect = <a class="el" href="structdi_1_1execution_1_1detail_1_1ConnectFunction.html">detail::ConnectFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3804bd611b2f8306950d2fc12af273f4" name="a3804bd611b2f8306950d2fc12af273f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3804bd611b2f8306950d2fc12af273f4">&#9670;&#160;</a></span>empty_sequence</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::empty_sequence = <a class="el" href="structdi_1_1execution_1_1empty__sequence__ns_1_1Function.html">empty_sequence_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sequence sender that completes immediately without ever sending a value. </p>

</div>
</div>
<a id="ac0b7f6b97142e5318a0231f1913c343c" name="ac0b7f6b97142e5318a0231f1913c343c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b7f6b97142e5318a0231f1913c343c">&#9670;&#160;</a></span>enable_receiver</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool di::execution::enable_receiver = requires { typename R::is_receiver; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5223ed86840b2c660e0f758de770586" name="af5223ed86840b2c660e0f758de770586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5223ed86840b2c660e0f758de770586">&#9670;&#160;</a></span>enable_sender</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool di::execution::enable_sender = requires { typename S::is_sender; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78a73036a389d16438460f568825cdfc" name="a78a73036a389d16438460f568825cdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a73036a389d16438460f568825cdfc">&#9670;&#160;</a></span>enable_sender&lt; S &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::IsAwaitable&lt; <a class="el" href="structdi_1_1execution_1_1EnvPromise.html">EnvPromise</a>&lt; <a class="el" href="structdi_1_1types_1_1EmptyEnv.html">types::EmptyEnv</a> &gt; &gt; S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="#af5223ed86840b2c660e0f758de770586">di::execution::enable_sender</a>&lt; S &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11e5885549fd5b1a99e397e3f21217dc" name="a11e5885549fd5b1a99e397e3f21217dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e5885549fd5b1a99e397e3f21217dc">&#9670;&#160;</a></span>enable_sequence_sender</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool di::execution::enable_sequence_sender = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e00afc6df733f05f17c4930613b84cb" name="a1e00afc6df733f05f17c4930613b84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e00afc6df733f05f17c4930613b84cb">&#9670;&#160;</a></span>enable_sequence_sender&lt; S &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; <br />
requires (concepts::AwaitableAsyncRange&lt;S&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="#a11e5885549fd5b1a99e397e3f21217dc">di::execution::enable_sequence_sender</a>&lt; S &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d29b9f071f6a569fae4e28807e09b41" name="a1d29b9f071f6a569fae4e28807e09b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d29b9f071f6a569fae4e28807e09b41">&#9670;&#160;</a></span>ensure_started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::ensure_started = <a class="el" href="structdi_1_1execution_1_1ensure__started__ns_1_1Function.html">ensure_started_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eagerly start a sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to start. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for the shared state (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that represents the original sender, but with the guarantee that it has started.</dd></dl>
<p>This function is used to eagerly start a sender, while still being able to retrieve its result later. It is implemented using a shared state, which is allocated using the provided allocator. If no allocator is provided, the default allocator is used.</p>
<p>If the returned sender is destroyed before it has been started, the eagerly started sender will be signalled by means of a stop token, possibly causing it to be cancelled. When the eagerly started sender completes, its values are decayed copied into the shared state, which is then used to complete the returned sender.</p>
<p>This function is an unstructured version of <a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">execution::spawn_future()</a>, which is used to eagerly start a sender in a provided async scope. This ensures that the eagerly started sender completes before the async scope is destroyed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">spawn_future</a> </dd></dl>

</div>
</div>
<a id="a6dff2641cb301865688bd130e8a37a24" name="a6dff2641cb301865688bd130e8a37a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dff2641cb301865688bd130e8a37a24">&#9670;&#160;</a></span>execute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::execute = <a class="el" href="structdi_1_1execution_1_1execute__ns_1_1Function.html">execute_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a function on a scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>The scheduler to execute the function on. </td></tr>
    <tr><td class="paramname">function</td><td>The function which runs on the provided scheduler. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to allocate the operation state (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possibly an error indicating the operaiton state could not be allocated.</dd></dl>
<p>This function is like <a class="el" href="#a346dc30954a7326dea7ad52b534a8a6d" title="Start a sender without waiting for it to complete.">execution::start_detached()</a> but does does not take a sender. Instead, it takes a function which is invoked by the provided scheduler, which ensures all work is executed on the scheduler.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a346dc30954a7326dea7ad52b534a8a6d" title="Start a sender without waiting for it to complete.">start_detached</a> </dd>
<dd>
<a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">then</a> </dd>
<dd>
<a class="el" href="#a3b8562510411c44ba43bed9f0eafdac4">schedule</a> </dd></dl>

</div>
</div>
<a id="a62e467f0beb1fff9106b8f27b5eade19" name="a62e467f0beb1fff9106b8f27b5eade19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e467f0beb1fff9106b8f27b5eade19">&#9670;&#160;</a></span>filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::filter = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1filter__ns_1_1Function.html">filter_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter the values of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence. </td></tr>
    <tr><td class="paramname">predicate</td><td>The function to filter the values of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The filtered sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The predicate function must be lvalue callable for each set of values produced by the sequence, and return a sender which yields a bool. If the sequence item is an error, the predicate function is not called. If the predicate function returns an error, that error is propagated as the result of the sequence.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the underlying sequence is not always lock-step, the predicate function must be thread-safe. If using a non-thread-safe predicate function, first call <a class="el" href="#aab707edaa7183d9de7470e063158164a" title="Converts a sequence into a lockstep sequence.">execution::into_lockstep_sequence()</a> on the sequence. </dd></dl>

</div>
</div>
<a id="a44c87368345e68d8b7342e32cd3b469a" name="a44c87368345e68d8b7342e32cd3b469a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c87368345e68d8b7342e32cd3b469a">&#9670;&#160;</a></span>first_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::first_value = <a class="el" href="structdi_1_1execution_1_1first__value__ns_1_1Function.html">first_value_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a sequence into a sender of its first value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender of the first value of the sequence.</dd></dl>
<p>This function will return the first error or value of the sequence after it completes. Any errors or values after the first will be ignored. However, if the cleanup action of the sequence sends an error, that error will be sent in place of the first value. If the sequence itself is empty, the returned sender will complete with a stopped signal.</p>
<p>See the following for an example: </p><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedi_1_1execution.html">execution</a> = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// first_value() returns the first value of a sequence.</span></div>
<div class="line">    <span class="keyword">auto</span> sequence = <a class="code hl_variable" href="#a3f0a3a801099bc8209937d00ed569421">execution::from_container</a>(<a class="code hl_variable" href="#a6608d87dcbac3f44f01bdd66fa1ffe8f">execution::valid_lifetime</a>, di::range(1, 5)) | <a class="code hl_variable" href="#a44c87368345e68d8b7342e32cd3b469a">execution::first_value</a>;</div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(sequence), 1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// first_value() propogates stops if no items are emitted.</span></div>
<div class="line">    <span class="keyword">auto</span> empty = <a class="code hl_variable" href="#a3804bd611b2f8306950d2fc12af273f4">execution::empty_sequence</a>() | <a class="code hl_variable" href="#a44c87368345e68d8b7342e32cd3b469a">execution::first_value</a>;</div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(empty), <a class="code hl_class" href="classdi_1_1vocab_1_1Unexpected.html">di::Unexpected</a>(di::BasicError::OperationCanceled));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a67e1a4201f686c5ce0ecf2b58599b68c" name="a67e1a4201f686c5ce0ecf2b58599b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e1a4201f686c5ce0ecf2b58599b68c">&#9670;&#160;</a></span>forwarding_query</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::forwarding_query = <a class="el" href="structdi_1_1execution_1_1ForwardingQuery.html">ForwardingQuery</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f0a3a801099bc8209937d00ed569421" name="a3f0a3a801099bc8209937d00ed569421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0a3a801099bc8209937d00ed569421">&#9670;&#160;</a></span>from_container</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::from_container = <a class="el" href="structdi_1_1execution_1_1from__container__ns_1_1Function.html">from_container_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sequence sender from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender which emits all values from the container.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The container is decay copied into sequence. When using a view instead, pass the <a class="el" href="#a6608d87dcbac3f44f01bdd66fa1ffe8f" title="Tag type to indicate that the container lifetime is valid for the async sequence.">execution::valid_lifetime</a> tag as the first argument, which allows the caller to assert that the view references data which will be valid for the lifetime of the sequence. This should only be used for data with static lifetime (e.g. string literals), or when referencing data which is stored in an operation state, when using a algorithm like <a class="el" href="#a3f922bb53c516baa85b259d3cf7b6d80">let_value()</a>.</dd>
<dd>
If the receiver's stop token is not an unstoppable token, the sequence will stop sending values if a stop is requested. </dd></dl>

</div>
</div>
<a id="ab71f340d93657c3e3a03c9922fbe4806" name="ab71f340d93657c3e3a03c9922fbe4806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71f340d93657c3e3a03c9922fbe4806">&#9670;&#160;</a></span>get_allocator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_allocator = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetAllocatorFunction.html">detail::GetAllocatorFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9308c827420ec17e30bfce196d0c7fb9" name="a9308c827420ec17e30bfce196d0c7fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9308c827420ec17e30bfce196d0c7fb9">&#9670;&#160;</a></span>get_completion_scheduler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::OneOf&lt; <a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a>, <a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a>, <a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a> &gt; CPO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_completion_scheduler = <a class="el" href="structdi_1_1execution_1_1GetCompletionScheduler.html">GetCompletionScheduler</a>&lt;CPO&gt; {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2d1c95b803c3135bdf3c01ab60dcb82" name="ac2d1c95b803c3135bdf3c01ab60dcb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d1c95b803c3135bdf3c01ab60dcb82">&#9670;&#160;</a></span>get_completion_signatures</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_completion_signatures = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetCompletionSignaturesFunction.html">detail::GetCompletionSignaturesFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12919e71dd61e140bbbf3f77d2439b50" name="a12919e71dd61e140bbbf3f77d2439b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12919e71dd61e140bbbf3f77d2439b50">&#9670;&#160;</a></span>get_delegatee_scheduler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_delegatee_scheduler = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetDelegateeSchedulerFunction.html">detail::GetDelegateeSchedulerFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf39d051bf85db72209739f920fb411e" name="aaf39d051bf85db72209739f920fb411e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf39d051bf85db72209739f920fb411e">&#9670;&#160;</a></span>get_env</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_env = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetEnvFunction.html">detail::GetEnvFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a378370171b93f20995a46c35fe327a58" name="a378370171b93f20995a46c35fe327a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378370171b93f20995a46c35fe327a58">&#9670;&#160;</a></span>get_forward_progress_guarantee</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_forward_progress_guarantee = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetForwardProgressGuaranteeFunction.html">detail::GetForwardProgressGuaranteeFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ab2d2447a0b5dfab6fb4ec912a51f1b" name="a9ab2d2447a0b5dfab6fb4ec912a51f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab2d2447a0b5dfab6fb4ec912a51f1b">&#9670;&#160;</a></span>get_scheduler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_scheduler = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetSchedulerFunction.html">detail::GetSchedulerFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a819fdd458add93fac4e126bb5e9ebfa1" name="a819fdd458add93fac4e126bb5e9ebfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819fdd458add93fac4e126bb5e9ebfa1">&#9670;&#160;</a></span>get_sequence_cardinality</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_sequence_cardinality = <a class="el" href="structdi_1_1execution_1_1get__sequence__cardinality__ns_1_1Function.html">get_sequence_cardinality_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A query that returns the cardinality of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The sequence's environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>di::Constexpr&lt;usize&gt;</code> instance.</dd></dl>
<p>This query allows optimizing the execution of a sequence by having a static upper bound on the number of values it will send. This could be used to know how many values to pre-allocate for a sequence, or to verify that a sequence only sends a single value (for an async resource).</p>
<p>This property should be queried using the <code><a class="el" href="namespacedi_1_1meta.html#ab64913eeb2d2e0394d55bee2958e411e" title="Gets the cardinality of a sequence.">meta::SequenceCardinality</a></code> template, which will return the cardinality of a sequence, or 1 in the case of a regular sender.</p>
<dl class="section note"><dt>Note</dt><dd>This query must return a <code>di::Constexpr&lt;usize&gt;</code> instance, so if this property varies at run-time (like for a type-erased sequence), it should return <code><a class="el" href="structdi_1_1math_1_1NumericLimits.html">math::NumericLimits</a>&lt;usize&gt;::max</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedi_1_1meta.html#ab64913eeb2d2e0394d55bee2958e411e" title="Gets the cardinality of a sequence.">meta::SequenceCardinality</a> </dd></dl>

</div>
</div>
<a id="aa33cf422a56fd4e70b6a5299349533b9" name="aa33cf422a56fd4e70b6a5299349533b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33cf422a56fd4e70b6a5299349533b9">&#9670;&#160;</a></span>get_stop_token</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::get_stop_token = <a class="el" href="structdi_1_1execution_1_1detail_1_1GetStopTokenFunction.html">detail::GetStopTokenFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a161d61fb3d9e428677872b18a4298ef0" name="a161d61fb3d9e428677872b18a4298ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161d61fb3d9e428677872b18a4298ef0">&#9670;&#160;</a></span>ignore_all</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::ignore_all = <a class="el" href="structdi_1_1execution_1_1ignore__all__ns_1_1Function.html">ignore_all_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapt a sequence sender to a regular sender of void, ignoring the sequence's values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence sender to adapt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender which sends an empty completion when the sequence completes.</dd></dl>
<p>If the sequence sender sends an error, the first error encountered is decay copied and forwarded to the receiver once the sequence completes. If instead the first non-value completion sent is a stop, the receiver is sent a stop when the sequence completes. Otherwise, the sent values are discarded and the receiver is sent an empty completion when the sequence completes.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="#a161d61fb3d9e428677872b18a4298ef0" title="Adapt a sequence sender to a regular sender of void, ignoring the sequence&#39;s values.">di::execution::ignore_all()</a> with a sequence sender corresponding to an infinte sequence will result in a sender which never completes. </dd></dl>

</div>
</div>
<a id="aab707edaa7183d9de7470e063158164a" name="aab707edaa7183d9de7470e063158164a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab707edaa7183d9de7470e063158164a">&#9670;&#160;</a></span>into_lockstep_sequence</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::into_lockstep_sequence = <a class="el" href="structdi_1_1execution_1_1into__lockstep__sequence__ns_1_1Function.html">into_lockstep_sequence_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a sequence into a lockstep sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A lockstep sequence.</dd></dl>
<p>This function is a no-op for sequences that are already lockstep. For non-lockstep sequences, this function will return a lockstep sequence, hopefully by using an atomic instrusive queue of operation states, but this is not yet implemented.</p>
<p>This function is useful for sequence algorithms which require lockstep sequences, like <a class="el" href="#ad70a9cea178eec6ca25e6163042fea06" title="Zip multiple sequences together.">execution::zip</a> and execution::fold, or any algorithm which cannot process results in parallel (which includes consuming sequences in a coroutine).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9901c7da667aac8d8b16c542cce6a708" title="A query that returns whether or not a sequence is always lockstep.">execution::is_always_lockstep_sequence</a> </dd>
<dd>
<a class="el" href="conceptdi_1_1concepts_1_1AlwaysLockstepSequence.html" title="Checks if Send is a sequence that is always lockstep.">concepts::AlwaysLockstepSequence</a> </dd></dl>

</div>
</div>
<a id="a6c563c907f1d1b9bea53a1b0dfeea6d2" name="a6c563c907f1d1b9bea53a1b0dfeea6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c563c907f1d1b9bea53a1b0dfeea6d2">&#9670;&#160;</a></span>into_result</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::into_result = <a class="el" href="structdi_1_1execution_1_1into__result__ns_1_1Function.html">into_result_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46b4ee8d7a0e7e7160c5cdcb719a8964" name="a46b4ee8d7a0e7e7160c5cdcb719a8964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b4ee8d7a0e7e7160c5cdcb719a8964">&#9670;&#160;</a></span>into_variant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::into_variant = <a class="el" href="structdi_1_1execution_1_1into__variant__ns_1_1Function.html">into_variant_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2657238be4f5696647e228e7ab49a996" name="a2657238be4f5696647e228e7ab49a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2657238be4f5696647e228e7ab49a996">&#9670;&#160;</a></span>into_variant_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::into_variant_each = <a class="el" href="structdi_1_1execution_1_1into__variant__each__ns_1_1Function.html">into_variant_each_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform the values of a sequence into a variant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that can only send a single value.</dd></dl>
<p>This function is like <a class="el" href="#a46b4ee8d7a0e7e7160c5cdcb719a8964">execution::into_variant()</a>, but for sequences.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a46b4ee8d7a0e7e7160c5cdcb719a8964">into_variant</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd></dl>

</div>
</div>
<a id="accbcaf8247a09df60b1e5ef786f58e18" name="accbcaf8247a09df60b1e5ef786f58e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbcaf8247a09df60b1e5ef786f58e18">&#9670;&#160;</a></span>into_variant_result</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::into_variant_result = <a class="el" href="structdi_1_1execution_1_1into__result__ns_1_1VariantFunction.html">into_result_ns::VariantFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a386071398ec9c52071a0754c9ca33e5e" name="a386071398ec9c52071a0754c9ca33e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386071398ec9c52071a0754c9ca33e5e">&#9670;&#160;</a></span>ipc_binary_connect_to_client</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::InstanceOf&lt; <a class="el" href="structdi_1_1execution_1_1Protocol.html">Protocol</a> &gt; Proto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::ipc_binary_connect_to_client = <a class="el" href="structdi_1_1execution_1_1ipc__binary__ns_1_1ConnectToClientFunction.html">ipc_binary_ns::ConnectToClientFunction</a>&lt;Proto&gt; {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a542a5d23d60497ba23476a1b8a9238fe" name="a542a5d23d60497ba23476a1b8a9238fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542a5d23d60497ba23476a1b8a9238fe">&#9670;&#160;</a></span>ipc_binary_connect_to_server</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::InstanceOf&lt; <a class="el" href="structdi_1_1execution_1_1Protocol.html">Protocol</a> &gt; Proto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::ipc_binary_connect_to_server = <a class="el" href="structdi_1_1execution_1_1ipc__binary__ns_1_1ConnectToServerFunction.html">ipc_binary_ns::ConnectToServerFunction</a>&lt;Proto&gt; {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9901c7da667aac8d8b16c542cce6a708" name="a9901c7da667aac8d8b16c542cce6a708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9901c7da667aac8d8b16c542cce6a708">&#9670;&#160;</a></span>is_always_lockstep_sequence</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::is_always_lockstep_sequence = <a class="el" href="structdi_1_1execution_1_1is__always__lockstop__sequence__ns_1_1Function.html">is_always_lockstop_sequence_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A query that returns whether or not a sequence is always lockstep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The sequence's environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>di::Constexpr&lt;bool&gt;</code> instance.</dd></dl>
<p>This query allows optimizing the execution of a sequence by guaranteeing that it does not ever make concurrent calls to <code><a class="el" href="#a2458c1749fcf4c3a9fe48a55ab8820ba" title="Set the next sender of a sequence.">execution::set_next()</a></code>. In particular, another call to <code><a class="el" href="#a2458c1749fcf4c3a9fe48a55ab8820ba" title="Set the next sender of a sequence.">execution::set_next()</a></code> can only be made once the sender returned by the previous call to <code><a class="el" href="#a2458c1749fcf4c3a9fe48a55ab8820ba" title="Set the next sender of a sequence.">execution::set_next()</a></code> has completed.</p>
<p>This is true for sequences such as those that are created by <code><a class="el" href="#a765a5e7168d2f4aded33132da901aadb">execution::AsyncGenerator</a></code> or <code><a class="el" href="#a3f0a3a801099bc8209937d00ed569421" title="Creates a sequence sender from a container.">execution::from_container</a></code>. This is also true for most sequence algorithms which operate on lockstep sequences, and for algorithms which must transform input sequences to be lockstep (like <a class="el" href="#ad70a9cea178eec6ca25e6163042fea06" title="Zip multiple sequences together.">execution::zip</a> and execution::fold). Additionally, this is true for sequences which only send a single value, including regular senders. However, since this is used as an optimization, it defaults to false, since falsely returning true will most likely will result in undefined behavior.</p>
<p>This property should be queried using the <code><a class="el" href="conceptdi_1_1concepts_1_1AlwaysLockstepSequence.html" title="Checks if Send is a sequence that is always lockstep.">concepts::AlwaysLockstepSequence</a></code> concept, which will return true if the sequence is a regular sender or a lockstep sequence. Additionally, any sequence with a cardinality less than or equal to 1 will automatically true.</p>
<dl class="section note"><dt>Note</dt><dd>This query must return a <code>di::Constexpr&lt;bool&gt;</code> instance, so if this property varies at run-time (like for a type-erased sequence), it must return false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="conceptdi_1_1concepts_1_1AlwaysLockstepSequence.html" title="Checks if Send is a sequence that is always lockstep.">concepts::AlwaysLockstepSequence</a> </dd></dl>

</div>
</div>
<a id="ae286b4db803b2d352cb9b5568a25da0a" name="ae286b4db803b2d352cb9b5568a25da0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae286b4db803b2d352cb9b5568a25da0a">&#9670;&#160;</a></span>is_debug_env</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::is_debug_env = <a class="el" href="structdi_1_1execution_1_1is__debug__env__ns_1_1Function.html">is_debug_env_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given environment is a debug environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given environment is a debug environment.</dd></dl>
<p>This is a debug mechanism, which forces the <a class="el" href="#ab8eb81db24d3e8757fd6129c0109dd10">execution::connect</a> or <a class="el" href="#a8b77b087d9dba9eef4d2b9d8edf17a6f" title="Subscribe a receiver to a sequence.">execution::subscribe</a> CPOs to call be valid even if no customization is valid. This is useful for seeing why a customization is not valid, since it will cause a compiler error when trying to call the CPO.</p>
<p>This mechanism is nice since it does not require manually editing the CPO to remove the constraints, which was the previous debugging mechanism.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab8eb81db24d3e8757fd6129c0109dd10">connect</a> </dd>
<dd>
<a class="el" href="#a8b77b087d9dba9eef4d2b9d8edf17a6f" title="Subscribe a receiver to a sequence.">subscribe</a> </dd>
<dd>
<a class="el" href="#a60221a32614bafb1421eae389a27facd" title="Adapts a sender to run with a debug environment.">with_debug_env</a> </dd></dl>

</div>
</div>
<a id="afd0227de21744a54490113644cf720e1" name="afd0227de21744a54490113644cf720e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0227de21744a54490113644cf720e1">&#9670;&#160;</a></span>just</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::just = <a class="el" href="structdi_1_1execution_1_1just__ns_1_1Function.html">just_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b26457a62e1f788c51d33b0c5cc1215" name="a3b26457a62e1f788c51d33b0c5cc1215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b26457a62e1f788c51d33b0c5cc1215">&#9670;&#160;</a></span>just_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::just_error = <a class="el" href="structdi_1_1execution_1_1just__ns_1_1ErrorFunction.html">just_ns::ErrorFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6346585630476aa77499b6dd569fe66" name="aa6346585630476aa77499b6dd569fe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6346585630476aa77499b6dd569fe66">&#9670;&#160;</a></span>just_from</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::just_from = <a class="el" href="structdi_1_1execution_1_1just__from__ns_1_1Function.html">just_from_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sender from a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function which is invoked to send a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender which invokes the provided function to send a value.</dd></dl>
<p>This function is like <a class="el" href="#afd0227de21744a54490113644cf720e1">execution::just()</a> but does does not take a value. Instead, it takes a function which is called when the operation is started. This is a shorthand for:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>() | <a class="code hl_variable" href="#a47211a8003b875bddec4f06aa8570ebb">execution::then</a>(function)</div>
<div class="ttc" id="anamespacedi_1_1execution_html_a47211a8003b875bddec4f06aa8570ebb"><div class="ttname"><a href="#a47211a8003b875bddec4f06aa8570ebb">di::execution::then</a></div><div class="ttdeci">constexpr auto then</div><div class="ttdoc">A sender that maps values into another value.</div><div class="ttdef"><b>Definition</b> then.h:274</div></div>
<div class="ttc" id="anamespacedi_1_1execution_html_afd0227de21744a54490113644cf720e1"><div class="ttname"><a href="#afd0227de21744a54490113644cf720e1">di::execution::just</a></div><div class="ttdeci">constexpr auto just</div><div class="ttdef"><b>Definition</b> just.h:86</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#afd0227de21744a54490113644cf720e1">just</a> </dd>
<dd>
<a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">then</a> </dd></dl>

</div>
</div>
<a id="ab2885b280666f68bcc51f6a3a518105a" name="ab2885b280666f68bcc51f6a3a518105a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2885b280666f68bcc51f6a3a518105a">&#9670;&#160;</a></span>just_or_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::just_or_error = <a class="el" href="structdi_1_1execution_1_1just__or__error__ns_1_1Function.html">just_or_error_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5dfbc3a12da3fdb5f57e8117230de9f" name="ad5dfbc3a12da3fdb5f57e8117230de9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5dfbc3a12da3fdb5f57e8117230de9f">&#9670;&#160;</a></span>just_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::just_stopped = <a class="el" href="structdi_1_1execution_1_1just__ns_1_1StoppedFunction.html">just_ns::StoppedFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3637afd55af27f54b03c3fda560d0de0" name="a3637afd55af27f54b03c3fda560d0de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3637afd55af27f54b03c3fda560d0de0">&#9670;&#160;</a></span>just_void_or_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::just_void_or_stopped = <a class="el" href="structdi_1_1execution_1_1just__void__or__stopped__ns_1_1Function.html">just_void_or_stopped_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8231ee42a7b11c83375fc729faf1c967" name="a8231ee42a7b11c83375fc729faf1c967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8231ee42a7b11c83375fc729faf1c967">&#9670;&#160;</a></span>let_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_error = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__ns_1_1Function.html">let_ns::Function</a>&lt;<a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a>&gt; {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69751d56705808577e80f2df326f1b53" name="a69751d56705808577e80f2df326f1b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69751d56705808577e80f2df326f1b53">&#9670;&#160;</a></span>let_error_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_error_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__each__ns_1_1ErrorFunction.html">let_each_ns::ErrorFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform the errors of a sequence into new senders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform the errors, which returns a sender.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that transforms the errors of the sequence into new senders.</dd></dl>
<p>This function allows mapping the errors of a sequence into values, which can be used to make the sequence complete successfully.</p>
<dl class="section note"><dt>Note</dt><dd>Like <a class="el" href="#a8231ee42a7b11c83375fc729faf1c967">execution::let_error</a>, the transformer function is passed lvalues internally stored in the operation state. This means they are safe to capture by reference in the transformer function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8231ee42a7b11c83375fc729faf1c967">let_error</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd></dl>

</div>
</div>
<a id="add7f1738fde8d5bf757f0dc871910533" name="add7f1738fde8d5bf757f0dc871910533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7f1738fde8d5bf757f0dc871910533">&#9670;&#160;</a></span>let_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_stopped = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__ns_1_1Function.html">let_ns::Function</a>&lt;<a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a>&gt; {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a945976c474bee70741a2daf4a80b1abd" name="a945976c474bee70741a2daf4a80b1abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945976c474bee70741a2daf4a80b1abd">&#9670;&#160;</a></span>let_stopped_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_stopped_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__each__ns_1_1StoppedFunction.html">let_each_ns::StoppedFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform the stopped signal of a sequence into new senders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform the stopped signal, which returns a sender.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that transforms the stopped signal of the sequence into new senders.</dd></dl>
<p>This function allows mapping the stopped signal of a sequence into values, which can be used to make the sequence never stop.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#add7f1738fde8d5bf757f0dc871910533">let_stopped</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd></dl>

</div>
</div>
<a id="a3f922bb53c516baa85b259d3cf7b6d80" name="a3f922bb53c516baa85b259d3cf7b6d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f922bb53c516baa85b259d3cf7b6d80">&#9670;&#160;</a></span>let_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_value = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__ns_1_1Function.html">let_ns::Function</a>&lt;<a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a>&gt; {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90d3aaea880b0a40fcdb5c5e0c72592d" name="a90d3aaea880b0a40fcdb5c5e0c72592d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d3aaea880b0a40fcdb5c5e0c72592d">&#9670;&#160;</a></span>let_value_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_value_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1let__each__ns_1_1ValueFunction.html">let_each_ns::ValueFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform the values of a sequence into new senders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform the values, which returns a sender.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that transforms the values of the sequence into new senders.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Like <a class="el" href="#a3f922bb53c516baa85b259d3cf7b6d80">execution::let_value</a>, the transformer function is passed lvalues internally stored in the operation state. This means they are safe to capture by reference in the transformer function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f922bb53c516baa85b259d3cf7b6d80">let_value</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd></dl>

</div>
</div>
<a id="a205ba3e1439f9a633846ec4768b07eac" name="a205ba3e1439f9a633846ec4768b07eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205ba3e1439f9a633846ec4768b07eac">&#9670;&#160;</a></span>let_value_with</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::let_value_with = <a class="el" href="structdi_1_1execution_1_1let__value__with__ns_1_1Function.html">let_value_with_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inject values into an operation state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function to invoke with the injected values. </td></tr>
    <tr><td class="paramname">factories</td><td>The factories to use to create the injected values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that injects the values into the operation state and invokes the function.</dd></dl>
<p>This function allows the injection of values into an operation state. These are given the the provided function as lvalues. And the function returns a sender which is allowed access to these values. This is particularly useful for creating immovable objects, which cannot be stored in a sender because senders must be movable.</p>
<p>The following example creates an injects a regular value, as well as an immovable value into the operation state. This demonstrates the <a class="el" href="namespacedi_1_1function.html#a172103573d8477f22133fb99516425fe" title="Creates a deferred function object.">function::make_deferred</a> helper function, which binds arguments to a constructor, as well as the fact that normal lambdas can be used as a factory function.</p>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedi_1_1execution.html">execution</a> = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>Y : <a class="code hl_struct" href="structdi_1_1util_1_1Immovable.html">di::Immovable</a> {</div>
<div class="line">        <span class="keyword">explicit</span> Y(<span class="keywordtype">int</span> value) : y(<a class="code hl_variable" href="namespacedi_1_1function.html#ada2f7be4e02d67b77f17e03cd0d1b9f0">value</a>) {}</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> y;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> a = <a class="code hl_variable" href="#a205ba3e1439f9a633846ec4768b07eac">execution::let_value_with</a>(</div>
<div class="line">        [](<span class="keywordtype">int</span>&amp; x, Y&amp; y) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(x + y.y);</div>
<div class="line">        },</div>
<div class="line">        [] {</div>
<div class="line">            <span class="keywordflow">return</span> 10;</div>
<div class="line">        },</div>
<div class="line">        di::make_deferred&lt;Y&gt;(32));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(di::move(a)), 42);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedi_1_1function.html#a172103573d8477f22133fb99516425fe" title="Creates a deferred function object.">function::make_deferred</a> </dd></dl>

</div>
</div>
<a id="a59274784714d063ff3e706df9ad50e9c" name="a59274784714d063ff3e706df9ad50e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59274784714d063ff3e706df9ad50e9c">&#9670;&#160;</a></span>make_env</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::make_env = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1Function.html">make_env_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an environment with overrides for queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_env</td><td>The base environment to use for forwarding queries that are not overridden. </td></tr>
    <tr><td class="paramname">overrides</td><td>The overrides to use for queries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An environment with the specified overrides.</dd></dl>
<p>This function creates an environment with the specified overrides. The overrides are specified as a list of objects returned from the <code><a class="el" href="#a885402d0ef97e17547751e4949ee96cc" title="Specify an override for an environment query.">execution::with</a></code> function. The overrides are required to be unique.</p>
<p>This function is also useful when creating an environment with no overrides, as it will only forward queries which have opted-in to be forwarded. This is useful when writng sender algorithms, which don't need to customize the environment but cannot pass the environment through directly to respect the forwarding-ness of the query.</p>
<p>See the <a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">execution::with_env()</a> function for an example.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a885402d0ef97e17547751e4949ee96cc" title="Specify an override for an environment query.">with</a> </dd>
<dd>
<a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">with_env</a> </dd></dl>

</div>
</div>
<a id="ac79c57f100fce9f000b54d4b5d4db498" name="ac79c57f100fce9f000b54d4b5d4db498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79c57f100fce9f000b54d4b5d4db498">&#9670;&#160;</a></span>nest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::nest = <a class="el" href="structdi_1_1execution_1_1nest__ns_1_1Function.html">nest_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nest a sender inside a scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>The scope to nest the sender inside. </td></tr>
    <tr><td class="paramname">sender</td><td>The sender to nest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that will run the sender inside the scope.</dd></dl>
<p>This is the most primitive way to nest a sender inside a scope. Nesting a sender inside of a scope means that the sender is required to complete before the scope is destroyed. This is useful in cases where we need to use a scope to manage the lifetime of a sender, as is the case any time the number of senders to be run is not known at compile time.</p>
<p>This function does not allocate any memory, and is therefore the most efficient way to nest a sender inside a scope, but is also the most inconvenient. In most cases, it is more desirable to use <a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">execution::spawn()</a> or <a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">execution::spawn_future()</a> instead. However, these functions can be implemented in terms of this function.</p>
<p>The following example demonstrates simple usage of <a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">execution::nest()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> nest_sender = <a class="code hl_variable" href="#a453eb71b631652bda317f20dd6aa2142">execution::use_resources</a>(</div>
<div class="line">    [](<span class="keyword">auto</span> scope) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="#a59d4a5552aeddba1c0e1882a482f1ace">execution::when_all</a>(<a class="code hl_variable" href="#ac79c57f100fce9f000b54d4b5d4db498">execution::nest</a>(scope, <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(11)),</div>
<div class="line">                                   <a class="code hl_variable" href="#ac79c57f100fce9f000b54d4b5d4db498">execution::nest</a>(scope, <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(22)),</div>
<div class="line">                                   <a class="code hl_variable" href="#ac79c57f100fce9f000b54d4b5d4db498">execution::nest</a>(scope, <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(33)));</div>
<div class="line">    },</div>
<div class="line">    di::make_deferred&lt;di::CountingScope&lt;&gt;&gt;());</div>
<div class="line"><a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(nest_sender), di::make_tuple(11, 22, 33));</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">spawn</a> </dd>
<dd>
<a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">spawn_future</a> </dd></dl>

</div>
</div>
<a id="a97ba685c3f5ce640b74e033026c51840" name="a97ba685c3f5ce640b74e033026c51840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ba685c3f5ce640b74e033026c51840">&#9670;&#160;</a></span>next</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::next = <a class="el" href="structdi_1_1execution_1_1next__ns_1_1Function.html">next_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next value of a async range in a coroutine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async_range</td><td>The lvalue async range to get the next value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An awaitable which will return the next value of the sequence.</dd></dl>
<p>This function is used in conjunction with co_await to consume an async sequence in a coroutine. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ex = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> g() -&gt; di::AsyncGenerator&lt;int&gt; {</div>
<div class="line">    <span class="keyword">co_yield</span> 1;</div>
<div class="line">    <span class="keyword">co_yield</span> 2;</div>
<div class="line">    <span class="keyword">co_yield</span> 3;</div>
<div class="line">    <span class="keyword">co_return</span> {};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f() -&gt; di::Lazy&lt;&gt; {</div>
<div class="line">    <span class="keyword">auto</span> sequence = <span class="keyword">co_await</span> g();</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_concept" href="conceptdi_1_1concepts_1_1Optional.html">di::concepts::Optional</a> <span class="keyword">auto</span> next = <span class="keyword">co_await</span> ex::next(sequence)) {</div>
<div class="line">        <a class="code hl_variable" href="namespacedius.html#ad71d4eb0ac6e6203978e53a8da644498">dius::println</a>(<span class="stringliteral">&quot;{}&quot;</span>_sv, *next);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aconceptdi_1_1concepts_1_1Optional_html"><div class="ttname"><a href="conceptdi_1_1concepts_1_1Optional.html">di::concepts::Optional</a></div><div class="ttdef"><b>Definition</b> vocab.h:77</div></div>
<div class="ttc" id="anamespacedi_1_1execution_html"><div class="ttname"><a href="namespacedi_1_1execution.html">di::execution</a></div><div class="ttdef"><b>Definition</b> bulk.h:30</div></div>
<div class="ttc" id="anamespacedius_html_ad71d4eb0ac6e6203978e53a8da644498"><div class="ttname"><a href="namespacedius.html#ad71d4eb0ac6e6203978e53a8da644498">dius::println</a></div><div class="ttdeci">constexpr auto println</div><div class="ttdef"><b>Definition</b> print.h:34</div></div>
</div><!-- fragment --><p>The key points are that the awaitable returned by <a class="el" href="#a97ba685c3f5ce640b74e033026c51840" title="Get the next value of a async range in a coroutine.">execution::next()</a> will return a <a class="el" href="classdi_1_1vocab_1_1Optional_3_01T_01_4.html">vocab::Optional&lt;T&gt;</a>, with the null value present once the sequence has been exhausted. This allows the sequence to be consumed in a while loop. </p>

</div>
</div>
<a id="af0027f43a9c5889062402b45528dce74" name="af0027f43a9c5889062402b45528dce74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0027f43a9c5889062402b45528dce74">&#9670;&#160;</a></span>on</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::on = <a class="el" href="structdi_1_1execution_1_1on__ns_1_1Function.html">on_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="#af0027f43a9c5889062402b45528dce74">execution::on()</a> takes a scheduler and sender, and returns a new sender whose which "runs" the provided sender on designated scheduler.</p>
<p>This is implemented by "connect"ing to the result of <a class="el" href="#a3b8562510411c44ba43bed9f0eafdac4">execution::schedule()</a>, and only starting the provided sender when that completes. Additionally, <a class="el" href="#af0027f43a9c5889062402b45528dce74">execution::on()</a> wraps any provided receivers with a new enviornment which adverties the scheduler for <a class="el" href="#a9ab2d2447a0b5dfab6fb4ec912a51f1b">execution::get_scheduler()</a>. </p>

</div>
</div>
<a id="a0bc8cd6c50b82282b51f5a5c4a300532" name="a0bc8cd6c50b82282b51f5a5c4a300532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc8cd6c50b82282b51f5a5c4a300532">&#9670;&#160;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::read = <a class="el" href="structdi_1_1execution_1_1read__ns_1_1Function.html">read_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b209d4eb75ee4d6bf75424453f35e8f" name="a3b209d4eb75ee4d6bf75424453f35e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b209d4eb75ee4d6bf75424453f35e8f">&#9670;&#160;</a></span>repeat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::repeat = <a class="el" href="structdi_1_1execution_1_1repeat__ns_1_1Function.html">repeat_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a copyable sender into an infinite sequence sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to repeat.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that will repeat the input sender infinitely. </dd></dl>

</div>
</div>
<a id="ab964d2c321fd09ebdc6a07dcfd7122ab" name="ab964d2c321fd09ebdc6a07dcfd7122ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab964d2c321fd09ebdc6a07dcfd7122ab">&#9670;&#160;</a></span>repeat_effect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::repeat_effect = <a class="el" href="structdi_1_1execution_1_1repeat__effect__ns_1_1Function.html">repeat_effect_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b6b0d93192d3ac5bfd91465d5d2a9b0" name="a7b6b0d93192d3ac5bfd91465d5d2a9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6b0d93192d3ac5bfd91465d5d2a9b0">&#9670;&#160;</a></span>repeat_effect_until</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::repeat_effect_until = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1repeat__effect__until__ns_1_1Function.html">repeat_effect_until_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fc6e885f72c4370ad160b678466bab6" name="a5fc6e885f72c4370ad160b678466bab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc6e885f72c4370ad160b678466bab6">&#9670;&#160;</a></span>request_stop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::request_stop = <a class="el" href="structdi_1_1execution_1_1request__stop__ns_1_1Function.html">request_stop_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that a scope stop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>The scope to request stop on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the scope was stopped, false if it was already.</dd></dl>
<p>This is used to request that a scope stop. In most cases, this is done by forwarding the request to the scope's underlyign stop source. Since this is a CPO, this provides a uniform interface to this functionality. </p>

</div>
</div>
<a id="a28a85fd1939a6e2c9ac31f1150bcd873" name="a28a85fd1939a6e2c9ac31f1150bcd873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a85fd1939a6e2c9ac31f1150bcd873">&#9670;&#160;</a></span>run</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::run = <a class="el" href="structdi_1_1execution_1_1run__ns_1_1Function.html">run_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain access to an async resource. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>The resource to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that can be used to access the resource.</dd></dl>
<p>This function is an internal CPO which is used by async resources. This function is not intended to be called directly. Resources should instead be consumed by using the <a class="el" href="#a453eb71b631652bda317f20dd6aa2142" title="Use async resources.">execution::use_resources</a> function.</p>
<p>Custom async resources must override this function to provide access to the resource. The returned sequence must send exactly one value and should complete when this value is accepted. The sent value should be some sort of token is used to access the resource. After the value is accepted, cleanup of the resource should be started if needed. Sending the value or completing can send errors if it makes sense to do so.</p>
<p>See the <a class="el" href="md_docs_2di_2execution.html">Execution</a> document for more information on the async resource model.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a453eb71b631652bda317f20dd6aa2142" title="Use async resources.">use_resources</a> </dd></dl>

</div>
</div>
<a id="a3b8562510411c44ba43bed9f0eafdac4" name="a3b8562510411c44ba43bed9f0eafdac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8562510411c44ba43bed9f0eafdac4">&#9670;&#160;</a></span>schedule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::schedule = <a class="el" href="structdi_1_1execution_1_1detail_1_1ScheduleFunction.html">detail::ScheduleFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae89cce9805c9c6cab6b275641d3ecf0b" name="ae89cce9805c9c6cab6b275641d3ecf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89cce9805c9c6cab6b275641d3ecf0b">&#9670;&#160;</a></span>schedule_from</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::schedule_from = <a class="el" href="structdi_1_1execution_1_1schedule__from__ns_1_1Function.html">schedule_from_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae00ed0a78cc202382fd181e8ed4b824f" name="ae00ed0a78cc202382fd181e8ed4b824f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00ed0a78cc202382fd181e8ed4b824f">&#9670;&#160;</a></span>send</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::send = <a class="el" href="structdi_1_1execution_1_1send__ns_1_1Function.html">send_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0feb1fba8e927043ba1e97e786af5b6f" name="a0feb1fba8e927043ba1e97e786af5b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0feb1fba8e927043ba1e97e786af5b6f">&#9670;&#160;</a></span>set_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::set_error = <a class="el" href="structdi_1_1execution_1_1SetError.html">SetError</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2458c1749fcf4c3a9fe48a55ab8820ba" name="a2458c1749fcf4c3a9fe48a55ab8820ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2458c1749fcf4c3a9fe48a55ab8820ba">&#9670;&#160;</a></span>set_next</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::set_next = <a class="el" href="structdi_1_1execution_1_1set__next__ns_1_1Function.html">set_next_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the next sender of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The receiver of the sequence. </td></tr>
    <tr><td class="paramname">sender</td><td>The sender to set as the next sender in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender which will adapt the values sent by <code>sender</code> to model <a class="el" href="conceptdi_1_1concepts_1_1NextSender.html" title="A sender that can be returned from di::execution::set_next().">di::concepts::NextSender</a>.</dd></dl>
<p>See the <a class="el" href="md_docs_2di_2execution.html">Execution</a> document for more information on the async sequence model. </p>

</div>
</div>
<a id="a7b8f3c564f58980589101202f543b7d0" name="a7b8f3c564f58980589101202f543b7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8f3c564f58980589101202f543b7d0">&#9670;&#160;</a></span>set_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::set_stopped = <a class="el" href="structdi_1_1execution_1_1SetStopped.html">SetStopped</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4325f4d43b09dc0cd01e9b559ce1c11" name="ad4325f4d43b09dc0cd01e9b559ce1c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4325f4d43b09dc0cd01e9b559ce1c11">&#9670;&#160;</a></span>set_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::set_value = <a class="el" href="structdi_1_1execution_1_1SetValue.html">SetValue</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cbdc8590257091c72345c9d73fdd262" name="a2cbdc8590257091c72345c9d73fdd262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbdc8590257091c72345c9d73fdd262">&#9670;&#160;</a></span>spawn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::spawn = <a class="el" href="structdi_1_1execution_1_1spawn__ns_1_1Function.html">spawn_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawn a sender inside a scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>The scope to spawn the sender inside. </td></tr>
    <tr><td class="paramname">sender</td><td>The sender to spawn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void if the sender was spawned successfully, otherwise an error.</dd></dl>
<p>This function is used to spawn a sender inside a scope. Spawning a sender inside a scope means that the sender is eagerly started, and the scope will not be destroyed until the sender completes. This is useful in cases where we need to run a dynamic amount of work, and make sure not to leak resources.</p>
<p>This function allocates the operation to be run on the heap, and is therefore less efficient than using <a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">execution::nest()</a>. However, it is more convenient, since it eagerly starts the sender, and still manages the memory properly. However, for this reason, if the underlying allocator is fallible, this function can return an error.</p>
<p>In cases where the result of the sender is needed, <a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">execution::spawn_future()</a> should be used instead.</p>
<p>The following example uses <a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">execution::spawn()</a> to start 10 tasks in parallel, and then waits for them to complete: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> count = 0;</div>
<div class="line"><span class="keyword">auto</span> spawn_sender = <a class="code hl_variable" href="#a453eb71b631652bda317f20dd6aa2142">execution::use_resources</a>(</div>
<div class="line">    [&amp;](<span class="keyword">auto</span> scope) {</div>
<div class="line">        di::for_each(di::range(10), [&amp;](<span class="keyword">auto</span>) {</div>
<div class="line">            <a class="code hl_variable" href="#a2cbdc8590257091c72345c9d73fdd262">execution::spawn</a>(scope, <a class="code hl_variable" href="#aa6346585630476aa77499b6dd569fe66">execution::just_from</a>([&amp;count] {</div>
<div class="line">                                 ++count;</div>
<div class="line">                             }));</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>();</div>
<div class="line">    },</div>
<div class="line">    di::make_deferred&lt;di::CountingScope&lt;&gt;&gt;());</div>
<div class="line"><a class="code hl_define" href="assert__bool_8h.html#af343b20373ba49a92fce523e948f2ab3">ASSERT</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(spawn_sender));</div>
<div class="line"><a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(count, 10);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The sender must not send any values or complete with an error (since the result is ignored). The only completion signatures allowed are di::SetValue() and di::SetStopped().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">nest</a> </dd>
<dd>
<a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">spawn_future</a> </dd></dl>

</div>
</div>
<a id="a9f91f698e51a9c7a9479c769e7aa69b3" name="a9f91f698e51a9c7a9479c769e7aa69b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f91f698e51a9c7a9479c769e7aa69b3">&#9670;&#160;</a></span>spawn_future</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::spawn_future = <a class="el" href="structdi_1_1execution_1_1spawn__future__ns_1_1Function.html">spawn_future_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawn a sender inside a scope, and return a future to the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>The scope to spawn the sender inside. </td></tr>
    <tr><td class="paramname">sender</td><td>The sender to spawn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender to the result of the sender.</dd></dl>
<p>This function is used to spawn a sender inside a scope, and return a future to the result. Spawning a sender means it is eagerly started, and the scope will not be destroyed until the sender completes. This differs from <a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">execution::nest()</a>, which does not eagerly start the sender.</p>
<p>This function is useful in cases where the result of the sender is needed. However, it is less efficient than both <a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">execution::nest()</a> and <a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">execution::spawn()</a>, since it allocates the operation to be run on the heap, and must resolve the race condition between the eagerly started sender completing, and the returned future being started.</p>
<p>The following example uses <a class="el" href="#a9f91f698e51a9c7a9479c769e7aa69b3" title="Spawn a sender inside a scope, and return a future to the result.">execution::spawn_future()</a> to start 4 tasks in parallel, and sums the results: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> spawn_future_sender = <a class="code hl_variable" href="#a453eb71b631652bda317f20dd6aa2142">execution::use_resources</a>(</div>
<div class="line">    [&amp;](<span class="keyword">auto</span> scope) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="#a9ab2d2447a0b5dfab6fb4ec912a51f1b">execution::get_scheduler</a>() | <a class="code hl_variable" href="#a3f922bb53c516baa85b259d3cf7b6d80">execution::let_value</a>([scope](<span class="keyword">auto</span> scheduler) {</div>
<div class="line">                   <span class="keywordflow">return</span> <a class="code hl_variable" href="#a59d4a5552aeddba1c0e1882a482f1ace">execution::when_all</a>(</div>
<div class="line">                              <a class="code hl_variable" href="#a9f91f698e51a9c7a9479c769e7aa69b3">execution::spawn_future</a>(scope, <a class="code hl_variable" href="#af0027f43a9c5889062402b45528dce74">execution::on</a>(scheduler, <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(11))),</div>
<div class="line">                              <a class="code hl_variable" href="#a9f91f698e51a9c7a9479c769e7aa69b3">execution::spawn_future</a>(scope, <a class="code hl_variable" href="#af0027f43a9c5889062402b45528dce74">execution::on</a>(scheduler, <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(22))),</div>
<div class="line">                              <a class="code hl_variable" href="#a9f91f698e51a9c7a9479c769e7aa69b3">execution::spawn_future</a>(scope, <a class="code hl_variable" href="#af0027f43a9c5889062402b45528dce74">execution::on</a>(scheduler, <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(33)))) |</div>
<div class="line">                          <a class="code hl_variable" href="#a47211a8003b875bddec4f06aa8570ebb">execution::then</a>([](<span class="keyword">auto</span>... values) {</div>
<div class="line">                              <span class="keywordflow">return</span> (values + ...);</div>
<div class="line">                          });</div>
<div class="line">               });</div>
<div class="line">    },</div>
<div class="line">    di::make_deferred&lt;di::CountingScope&lt;&gt;&gt;());</div>
<div class="line"><a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(spawn_future_sender), 66);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac79c57f100fce9f000b54d4b5d4db498" title="Nest a sender inside a scope.">nest</a> </dd>
<dd>
<a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">spawn</a> </dd></dl>

</div>
</div>
<a id="a8a7e7d8e81c15fe09e8d1138a1ad9943" name="a8a7e7d8e81c15fe09e8d1138a1ad9943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7e7d8e81c15fe09e8d1138a1ad9943">&#9670;&#160;</a></span>split</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::split = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1split__ns_1_1Function.html">split_ns::Function</a> {}, c_&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a sender into a sender which sends the same value to multiple receivers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to split. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for the shared state (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender which sends the same value to multiple receivers, or an error if allocation failed.</dd></dl>
<p>This function enables a sender to be split into multiple receivers. The returned sender will send the same value to all receivers. This requires an atomic queue of waiting receivers, which is stored in a heap-allocated shared state. The underlying sender is only started when the first operation is started.</p>
<dl class="section note"><dt>Note</dt><dd>The returned sender does not copy-out the values, but passes them by const reference. </dd></dl>

</div>
</div>
<a id="a4489f2f3c368ba297e8982d77dd3e27d" name="a4489f2f3c368ba297e8982d77dd3e27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4489f2f3c368ba297e8982d77dd3e27d">&#9670;&#160;</a></span>start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::start = <a class="el" href="structdi_1_1execution_1_1detail_1_1StartFunction.html">detail::StartFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a346dc30954a7326dea7ad52b534a8a6d" name="a346dc30954a7326dea7ad52b534a8a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346dc30954a7326dea7ad52b534a8a6d">&#9670;&#160;</a></span>start_detached</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::start_detached = <a class="el" href="structdi_1_1execution_1_1start__detached__ns_1_1Function.html">start_detached_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a sender without waiting for it to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to start. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for the operation state (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possibly an error indicating the operaiton state could not be allocated.</dd></dl>
<p>This function is used to start a sender in a fire-and-forget manner. The operation state is heap allocated using the provided allocator. If no allocator is provided, the default allocator is used. If allocation is failible, this function will return an error.</p>
<p>This function is like <a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">execution::spawn()</a> but does not require a scope to be provided. This means that the sender may remain pending for an arbitrary amount of time, and the operation state will not be destroyed until the sender completes. As such, this function should be used with care, since it can easily lead to unpredictable resource usage.</p>
<dl class="section note"><dt>Note</dt><dd>The sender must not send any values or complete with an error (since the result is ignored). The only completion signatures allowed are di::SetValue() and di::SetStopped().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2cbdc8590257091c72345c9d73fdd262" title="Spawn a sender inside a scope.">spawn</a> </dd></dl>

</div>
</div>
<a id="a2793e3e2023b1588f32defbcb3545558" name="a2793e3e2023b1588f32defbcb3545558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2793e3e2023b1588f32defbcb3545558">&#9670;&#160;</a></span>stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::stopped = <a class="el" href="#ad5dfbc3a12da3fdb5f57e8117230de9f">just_stopped</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3278327cc615b4157fe42c14f2945e2d" name="a3278327cc615b4157fe42c14f2945e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3278327cc615b4157fe42c14f2945e2d">&#9670;&#160;</a></span>stopped_as_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::stopped_as_error = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1stopped__as__error__ns_1_1Function.html">stopped_as_error_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abcfc7372601ab39f71efa9807722bc8e" name="abcfc7372601ab39f71efa9807722bc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfc7372601ab39f71efa9807722bc8e">&#9670;&#160;</a></span>stopped_as_optional</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::stopped_as_optional = <a class="el" href="structdi_1_1execution_1_1stopped__as__optional__ns_1_1Function.html">stopped_as_optional_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b77b087d9dba9eef4d2b9d8edf17a6f" name="a8b77b087d9dba9eef4d2b9d8edf17a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b77b087d9dba9eef4d2b9d8edf17a6f">&#9670;&#160;</a></span>subscribe</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::subscribe = <a class="el" href="structdi_1_1execution_1_1subscribe__ns_1_1Function.html">subscribe_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe a receiver to a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to subscribe to. </td></tr>
    <tr><td class="paramname">receiver</td><td>The receiver to subscribe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An operation state which models <a class="el" href="conceptdi_1_1concepts_1_1OperationState.html">di::concepts::OperationState</a>. </dd></dl>

</div>
</div>
<a id="ade695b89fbe1983c09a3a47d097dcfbb" name="ade695b89fbe1983c09a3a47d097dcfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade695b89fbe1983c09a3a47d097dcfbb">&#9670;&#160;</a></span>sync_wait</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::sync_wait = <a class="el" href="structdi_1_1execution_1_1sync__wait__ns_1_1Function.html">sync_wait_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab395b6eab39b5b30a20e18aed59a9765" name="ab395b6eab39b5b30a20e18aed59a9765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab395b6eab39b5b30a20e18aed59a9765">&#9670;&#160;</a></span>sync_wait_on</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::sync_wait_on = <a class="el" href="namespacedi_1_1function.html#af1d3c6e7586b42e06d117953bdb84d02">function::curry</a>(<a class="el" href="structdi_1_1execution_1_1sync__wait__ns_1_1OnFunction.html">sync_wait_ns::OnFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb87b87297720f590fb4973e60894d7f" name="afb87b87297720f590fb4973e60894d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb87b87297720f590fb4973e60894d7f">&#9670;&#160;</a></span>sync_wait_with_variant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::sync_wait_with_variant = <a class="el" href="structdi_1_1execution_1_1sync__wait__ns_1_1WithVariantFunction.html">sync_wait_ns::WithVariantFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65f129b3d1671aecfb288063d90c6ed7" name="a65f129b3d1671aecfb288063d90c6ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f129b3d1671aecfb288063d90c6ed7">&#9670;&#160;</a></span>sync_wait_with_variant_on</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::sync_wait_with_variant_on</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    function::curry(sync_wait_ns::WithVariantOnFunction {}, meta::c_&lt;2zu&gt;)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a47211a8003b875bddec4f06aa8570ebb" name="a47211a8003b875bddec4f06aa8570ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47211a8003b875bddec4f06aa8570ebb">&#9670;&#160;</a></span>then</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::then = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__ns_1_1ValueFunction.html">then_ns::ValueFunction</a> {}, c_&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sender that maps values into another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to map. </td></tr>
    <tr><td class="paramname">function</td><td>The function to map the value with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that maps values into another value.</dd></dl>
<p>This function synchronously maps values into another value. Additionally, the function can return an di::Expected, which will be mapped into a value or an error.</p>
<p>If the transformation function wants to be asynchronous, use <a class="el" href="#a3f922bb53c516baa85b259d3cf7b6d80">execution::let_value()</a> instead, which allows the function to return a sender.</p>
<p>The following examples show how to use this function: </p><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedi_1_1execution.html">execution</a> = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line">    di::Sender <span class="keyword">auto</span> work = <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>(42) | <a class="code hl_variable" href="#a47211a8003b875bddec4f06aa8570ebb">execution::then</a>([](<span class="keywordtype">int</span> x) {</div>
<div class="line">                               <span class="keywordflow">return</span> x * 2;</div>
<div class="line">                           });</div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(work), 84);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> failure = <a class="code hl_variable" href="#afd0227de21744a54490113644cf720e1">execution::just</a>() | <a class="code hl_variable" href="#a47211a8003b875bddec4f06aa8570ebb">execution::then</a>([] {</div>
<div class="line">                       <span class="keywordflow">return</span> di::Result&lt;int&gt;(<a class="code hl_class" href="classdi_1_1vocab_1_1Unexpected.html">di::Unexpected</a>(di::BasicError::InvalidArgument));</div>
<div class="line">                   });</div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(failure), <a class="code hl_class" href="classdi_1_1vocab_1_1Unexpected.html">di::Unexpected</a>(di::BasicError::InvalidArgument));</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f922bb53c516baa85b259d3cf7b6d80">let_value</a> </dd></dl>

</div>
</div>
<a id="aeb2dfb9dbd067eec2c5750ca3006c2b8" name="aeb2dfb9dbd067eec2c5750ca3006c2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2dfb9dbd067eec2c5750ca3006c2b8">&#9670;&#160;</a></span>then_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::then_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__each__ns_1_1Function.html">then_each_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform the values of a sequence directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform the values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that transforms the values of the sequence directly.</dd></dl>
<p>This function is the equivalent of <a class="el" href="namespacedi_1_1container_1_1view.html#a6aa4b99ec45c0e3e9ab9d7a4c5827689">view::transform()</a>, but for sequences. However, the transformer is allowed to return a <a class="el" href="namespacedi_1_1vocab.html#a4b09c0549df9e19456d5f00ccc6b8585">vocab::Result&lt;T&gt;</a> instead of a T, which will propogate the error out of the sequence.</p>
<dl class="section note"><dt>Note</dt><dd>Like <a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">execution::then</a>, the transformer function is passed values directly, so parameters should be taken by value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">then</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd>
<dd>
<a class="el" href="namespacedi_1_1container_1_1view.html#a6aa4b99ec45c0e3e9ab9d7a4c5827689">view::transform</a> </dd></dl>

</div>
</div>
<a id="a3a6de8bf32d512d1109632101d864b5d" name="a3a6de8bf32d512d1109632101d864b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6de8bf32d512d1109632101d864b5d">&#9670;&#160;</a></span>transfer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::transfer = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1transfer__ns_1_1Function.html">transfer_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83b99bb9686eb67a9d5bca7a3b9c5738" name="a83b99bb9686eb67a9d5bca7a3b9c5738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b99bb9686eb67a9d5bca7a3b9c5738">&#9670;&#160;</a></span>transfer_just</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::transfer_just = <a class="el" href="structdi_1_1execution_1_1transfer__just__ns_1_1Function.html">transfer_just_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafecdb3cff7d34407a8440677b59c83a" name="aafecdb3cff7d34407a8440677b59c83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafecdb3cff7d34407a8440677b59c83a">&#9670;&#160;</a></span>transfer_when_all</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::transfer_when_all = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1TransferFunction.html">when_all_ns::TransferFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa00043a6029f693e167fe5eabb86096c" name="aa00043a6029f693e167fe5eabb86096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00043a6029f693e167fe5eabb86096c">&#9670;&#160;</a></span>transfer_when_all_with_variant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::transfer_when_all_with_variant = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1TransferVariantFunction.html">when_all_ns::TransferVariantFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f9a7f408586ff517531ce1b7daf9fab" name="a8f9a7f408586ff517531ce1b7daf9fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9a7f408586ff517531ce1b7daf9fab">&#9670;&#160;</a></span>transform_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::transform_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1transform__each__ns_1_1Function.html">transform_each_ns::Function</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform each sender of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform each sender of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The transformer function must be lvalue callable for each sender of the sequence, and return a sender. Additionally, the completion signatures of the return sender must only depend on the completion signatures of the input sender, as the determination of completion signatures is done without any knowledge of the exact type of the sequence's senders.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the underlying sequence is not always lock-step, the transformer function must be thread-safe. If using a non-thread-safe transformer function, first call <a class="el" href="#aab707edaa7183d9de7470e063158164a" title="Converts a sequence into a lockstep sequence.">execution::into_lockstep_sequence()</a> on the sequence. </dd></dl>

</div>
</div>
<a id="a6399cc2f6d400abcbcc4382472dc5411" name="a6399cc2f6d400abcbcc4382472dc5411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6399cc2f6d400abcbcc4382472dc5411">&#9670;&#160;</a></span>upon_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::upon_error = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__ns_1_1ErrorFunction.html">then_ns::ErrorFunction</a> {}, c_&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sender that maps an error into a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to map. </td></tr>
    <tr><td class="paramname">function</td><td>The function to map the error with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that maps an error into a value.</dd></dl>
<p>This function is like <a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">execution::then()</a>, but instead of mapping values into another value, it maps an error into a value. Additionally, the function can return an di::Expected, which will be mapped into a value or an error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">then</a> </dd></dl>

</div>
</div>
<a id="a550e6db854b2100fd29de808b36fa00f" name="a550e6db854b2100fd29de808b36fa00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550e6db854b2100fd29de808b36fa00f">&#9670;&#160;</a></span>upon_error_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::upon_error_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__each__ns_1_1ErrorFunction.html">then_each_ns::ErrorFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform the errors of a sequence directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform the errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that transforms the errors of the sequence directly.</dd></dl>
<p>This function is <a class="el" href="#aeb2dfb9dbd067eec2c5750ca3006c2b8" title="Transform the values of a sequence directly.">execution::then_each()</a>, but maps errors instead of values. The transformer is allowed to return a <a class="el" href="namespacedi_1_1vocab.html#a4b09c0549df9e19456d5f00ccc6b8585">vocab::Result&lt;T&gt;</a> instead of a T, which will propogate the error out of the sequence.</p>
<dl class="section note"><dt>Note</dt><dd>Like <a class="el" href="#a6399cc2f6d400abcbcc4382472dc5411" title="A sender that maps an error into a value.">execution::upon_error</a>, the transformer function is passed errors directly, so parameters should be taken by value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6399cc2f6d400abcbcc4382472dc5411" title="A sender that maps an error into a value.">upon_error</a> </dd>
<dd>
<a class="el" href="#aeb2dfb9dbd067eec2c5750ca3006c2b8" title="Transform the values of a sequence directly.">then_each</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd></dl>

</div>
</div>
<a id="a05cc46124e7aa88abda089c2817c72ba" name="a05cc46124e7aa88abda089c2817c72ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cc46124e7aa88abda089c2817c72ba">&#9670;&#160;</a></span>upon_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::upon_stopped = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__ns_1_1StoppedFunction.html">then_ns::StoppedFunction</a> {}, c_&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sender that maps the stop signal into a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to map. </td></tr>
    <tr><td class="paramname">function</td><td>The function to map the stop signal with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that maps the stop signal into a value.</dd></dl>
<p>This function is like <a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">execution::then()</a>, but instead of mapping values into another value, it maps the stop signal into a value. Additionally, the function can return an di::Expected, which will be mapped into a value or an error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a47211a8003b875bddec4f06aa8570ebb" title="A sender that maps values into another value.">then</a> </dd></dl>

</div>
</div>
<a id="a069327ec13983f51238939454b13b411" name="a069327ec13983f51238939454b13b411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069327ec13983f51238939454b13b411">&#9670;&#160;</a></span>upon_stopped_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::upon_stopped_each = <a class="el" href="namespacedi_1_1function.html#aafd3893213f74287a88e02b5399f6c42">function::curry_back</a>(<a class="el" href="structdi_1_1execution_1_1then__each__ns_1_1StoppedFunction.html">then_each_ns::StoppedFunction</a> {}, <a class="el" href="namespacedi_1_1meta.html#a8fb871f0fbf357420b60af3be3dd6502">meta::c_</a>&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform stopped values of a sequence directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>The sequence to transform. </td></tr>
    <tr><td class="paramname">transformer</td><td>The function to transform the stopped values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that transforms the stopped values of the sequence directly.</dd></dl>
<p>This function is <a class="el" href="#aeb2dfb9dbd067eec2c5750ca3006c2b8" title="Transform the values of a sequence directly.">execution::then_each()</a>, but runs when the sequence sends stopped instead of values. The transformer is allowed to return a <a class="el" href="namespacedi_1_1vocab.html#a4b09c0549df9e19456d5f00ccc6b8585">vocab::Result&lt;T&gt;</a> instead of a T, which will propogate the error out of the sequence.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a05cc46124e7aa88abda089c2817c72ba" title="A sender that maps the stop signal into a value.">upon_stopped</a> </dd>
<dd>
<a class="el" href="#aeb2dfb9dbd067eec2c5750ca3006c2b8" title="Transform the values of a sequence directly.">then_each</a> </dd>
<dd>
<a class="el" href="#a8f9a7f408586ff517531ce1b7daf9fab" title="Transform each sender of a sequence.">transform_each</a> </dd></dl>

</div>
</div>
<a id="a453eb71b631652bda317f20dd6aa2142" name="a453eb71b631652bda317f20dd6aa2142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453eb71b631652bda317f20dd6aa2142">&#9670;&#160;</a></span>use_resources</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::use_resources = <a class="el" href="structdi_1_1execution_1_1use__resources__ns_1_1Function.html">use_resources_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use async resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function which accepts the resources. </td></tr>
    <tr><td class="paramname">deferred</td><td>Possibly multiple factories which return async resources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender which runs the sender returned from the function.</dd></dl>
<p>This function allows consuming multiple async resources in parallel. If any resource fails to be acquired, the returned sender sends an error. Likewise, if any cleanup fails, the returned sender sends an error. The provided function is only invoked if all resources are successfully acquired. The values sent by the function are forwarded to the returned sender.</p>
<p>The values passed to the function are the async resource tokens. These are regular types which internally have reference semantics. They refer to the actual resouce objects, which are stored in an internal operation state. This function is the recommended way to consume async resources, since it guarantees that the resources are acquired and released, and even does so in parallel.</p>
<p>See the following usage example: </p><div class="fragment"></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a28a85fd1939a6e2c9ac31f1150bcd873" title="Obtain access to an async resource.">run</a> </dd></dl>

</div>
</div>
<a id="a6608d87dcbac3f44f01bdd66fa1ffe8f" name="a6608d87dcbac3f44f01bdd66fa1ffe8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6608d87dcbac3f44f01bdd66fa1ffe8f">&#9670;&#160;</a></span>valid_lifetime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::valid_lifetime = <a class="el" href="structdi_1_1execution_1_1from__container__ns_1_1ValidLifetimeTag.html">from_container_ns::ValidLifetimeTag</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag type to indicate that the container lifetime is valid for the async sequence. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f0a3a801099bc8209937d00ed569421" title="Creates a sequence sender from a container.">from_container</a> </dd></dl>

</div>
</div>
<a id="a59d4a5552aeddba1c0e1882a482f1ace" name="a59d4a5552aeddba1c0e1882a482f1ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4a5552aeddba1c0e1882a482f1ace">&#9670;&#160;</a></span>when_all</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::when_all = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1Function.html">when_all_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc8a966b11db02228d1e8d9c002fb9f4" name="afc8a966b11db02228d1e8d9c002fb9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8a966b11db02228d1e8d9c002fb9f4">&#9670;&#160;</a></span>when_all_with_variant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::when_all_with_variant = <a class="el" href="structdi_1_1execution_1_1when__all__ns_1_1VariantFunction.html">when_all_ns::VariantFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a885402d0ef97e17547751e4949ee96cc" name="a885402d0ef97e17547751e4949ee96cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885402d0ef97e17547751e4949ee96cc">&#9670;&#160;</a></span>with</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::with = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1WithFunction.html">make_env_ns::WithFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify an override for an environment query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag of the query to override. </td></tr>
    <tr><td class="paramname">value</td><td>The value to use for the override.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An override object that can be passed to the <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function</dd></dl>
<p>This function is used as a parameter to <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function to specify an override for a query. The query values are required to be copy constructible, they are decay copied into the environment, and they are copied out when the environment is queried.</p>
<p>See the <a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">execution::with_env()</a> function for an example.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">make_env</a> </dd>
<dd>
<a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">with_env</a> </dd></dl>

</div>
</div>
<a id="a60221a32614bafb1421eae389a27facd" name="a60221a32614bafb1421eae389a27facd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60221a32614bafb1421eae389a27facd">&#9670;&#160;</a></span>with_debug_env</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::with_debug_env = <a class="el" href="structdi_1_1execution_1_1with__env__ns_1_1DebugFunction.html">with_env_ns::DebugFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapts a sender to run with a debug environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The sender to adapt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that runs the specified sender with a debug environment.</dd></dl>
<p>This function is equivalent to calling <a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">with_env()</a> with a debug environment.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">with_env</a> </dd>
<dd>
<a class="el" href="#ae286b4db803b2d352cb9b5568a25da0a" title="Returns whether the given environment is a debug environment.">is_debug_env</a> </dd></dl>

</div>
</div>
<a id="a66465006d06c4717b83e28913ffb4fae" name="a66465006d06c4717b83e28913ffb4fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66465006d06c4717b83e28913ffb4fae">&#9670;&#160;</a></span>with_env</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::with_env = <a class="el" href="namespacedi_1_1function.html#af1d3c6e7586b42e06d117953bdb84d02">function::curry</a>(<a class="el" href="structdi_1_1execution_1_1with__env__ns_1_1Function.html">with_env_ns::Function</a> {}, c_&lt;2zu&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapts a sender to run with a specified environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to run the sender with. </td></tr>
    <tr><td class="paramname">sender</td><td>The sender to adapt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sender that runs the specified sender with the specified environment.</dd></dl>
<p>This functions allows injecting an environment into a sender. The environment is accessible within the sender using <a class="el" href="#a0bc8cd6c50b82282b51f5a5c4a300532">execution::read()</a>, and allows the sender to dynamically get things like a stop token, allocator, or current scheduler.</p>
<p>The following is an example of a sender that uses its injected stop token to know if it should stop itself:</p>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedi_1_1execution.html">execution</a> = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> stop_source = <a class="code hl_class" href="classdi_1_1sync_1_1InPlaceStopSource.html">di::InPlaceStopSource</a> {};</div>
<div class="line">    <span class="keyword">auto</span> env =</div>
<div class="line">        <a class="code hl_variable" href="#a59274784714d063ff3e706df9ad50e9c">execution::make_env</a>(di::empty_env, <a class="code hl_variable" href="#a885402d0ef97e17547751e4949ee96cc">execution::with</a>(<a class="code hl_variable" href="#aa33cf422a56fd4e70b6a5299349533b9">execution::get_stop_token</a>, stop_source.get_stop_token()));</div>
<div class="line">    <span class="keyword">auto</span> send = <a class="code hl_variable" href="#a0bc8cd6c50b82282b51f5a5c4a300532">execution::read</a>(<a class="code hl_variable" href="#aa33cf422a56fd4e70b6a5299349533b9">execution::get_stop_token</a>) | <a class="code hl_variable" href="#a3f922bb53c516baa85b259d3cf7b6d80">execution::let_value</a>([](<span class="keyword">auto</span> stop_token) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code hl_variable" href="#a3637afd55af27f54b03c3fda560d0de0">execution::just_void_or_stopped</a>(stop_token.stop_requested());</div>
<div class="line">                });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The sender will run to completion if stop is not .</span></div>
<div class="line">    <a class="code hl_define" href="assert__bool_8h.html#af343b20373ba49a92fce523e948f2ab3">ASSERT</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(<a class="code hl_variable" href="#a66465006d06c4717b83e28913ffb4fae">execution::with_env</a>(env, send)));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// After requesting stop, the sender will return cancelled.</span></div>
<div class="line">    stop_source.request_stop();</div>
<div class="line">    <a class="code hl_define" href="assert__bool_8h.html#af343b20373ba49a92fce523e948f2ab3">ASSERT</a>(!<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(<a class="code hl_variable" href="#a66465006d06c4717b83e28913ffb4fae">execution::with_env</a>(env, send)));</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a885402d0ef97e17547751e4949ee96cc" title="Specify an override for an environment query.">with</a> </dd>
<dd>
<a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">make_env</a> </dd>
<dd>
<a class="el" href="#a0bc8cd6c50b82282b51f5a5c4a300532">read</a> </dd></dl>

</div>
</div>
<a id="a1309fd4bdf38e54cb705408875651040" name="a1309fd4bdf38e54cb705408875651040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1309fd4bdf38e54cb705408875651040">&#9670;&#160;</a></span>without</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::without = <a class="el" href="structdi_1_1execution_1_1make__env__ns_1_1WithoutFunction.html">make_env_ns::WithoutFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify a removal of an environment query override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag of the query to remove the override for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An override object that can be passed to the <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function</dd></dl>
<p>This function is used as a parameter to <code><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">execution::make_env</a></code> function to specify a removal an existing environment value. This is useful when forwarding an environment, but removing a value that is not valid in the new environment.</p>
<p>See the <a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">execution::with_env()</a> function for an example.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a59274784714d063ff3e706df9ad50e9c" title="Create an environment with overrides for queries.">make_env</a> </dd>
<dd>
<a class="el" href="#a66465006d06c4717b83e28913ffb4fae" title="Adapts a sender to run with a specified environment.">with_env</a> </dd></dl>

</div>
</div>
<a id="ad70a9cea178eec6ca25e6163042fea06" name="ad70a9cea178eec6ca25e6163042fea06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70a9cea178eec6ca25e6163042fea06">&#9670;&#160;</a></span>zip</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::zip = <a class="el" href="structdi_1_1execution_1_1zip__ns_1_1Function.html">zip_ns::Function</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip multiple sequences together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequences</td><td>The sequences to zip together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that sends each value of each sequence together.</dd></dl>
<p>This function is like <a class="el" href="namespacedi_1_1container_1_1view.html#a23256042ce7c04f4dd611149b13d7065">view::zip()</a> for ranges, but for sequences. Like <a class="el" href="#a59d4a5552aeddba1c0e1882a482f1ace">when_all()</a>, the senders are required to only send a single type of values. If you need to send multiple types of values, use <a class="el" href="#acc8be53f60722f84d102c011699172ac" title="Zip multiple sequences together, allowing them to send different types of values.">zip_with_variant()</a>.</p>
<p>This function is used to combine multiple sequences together into a single sequence. For example:</p>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedi_1_1execution.html">execution</a> = <a class="code hl_namespace" href="namespacedi_1_1execution.html">di::execution</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// zip() works in normal conditions.</span></div>
<div class="line">    <span class="keyword">auto</span> sequence = <a class="code hl_variable" href="#ad70a9cea178eec6ca25e6163042fea06">execution::zip</a>(<a class="code hl_variable" href="#a3f0a3a801099bc8209937d00ed569421">execution::from_container</a>(<a class="code hl_struct" href="structdi_1_1vocab_1_1Array.html">di::Array</a> { 1, 2, 3 }),</div>
<div class="line">                                   <a class="code hl_variable" href="#a3f0a3a801099bc8209937d00ed569421">execution::from_container</a>(<a class="code hl_struct" href="structdi_1_1vocab_1_1Array.html">di::Array</a> { 4, 5, 6 }));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> sum = 0;</div>
<div class="line">    <a class="code hl_define" href="assert__bool_8h.html#af343b20373ba49a92fce523e948f2ab3">ASSERT</a>(<a class="code hl_variable" href="#ade695b89fbe1983c09a3a47d097dcfbb">execution::sync_wait</a>(<a class="code hl_variable" href="#a161d61fb3d9e428677872b18a4298ef0">execution::ignore_all</a>(sequence | <a class="code hl_variable" href="#aeb2dfb9dbd067eec2c5750ca3006c2b8">execution::then_each</a>([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {</div>
<div class="line">                                                          sum += x * y;</div>
<div class="line">                                                      }))));</div>
<div class="line">    <a class="code hl_define" href="assert__binary_8h.html#ab601785d192462f8e12893f57052b29a">ASSERT_EQ</a>(sum, 32);</div>
</div><!-- fragment --><p>The sequences passed to this function will first be converted to lockstep sequences using <a class="el" href="#aab707edaa7183d9de7470e063158164a" title="Converts a sequence into a lockstep sequence.">into_lockstep_sequence()</a>. As a result, the sequence returned by this function will be a lockstep sequence.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acc8be53f60722f84d102c011699172ac" title="Zip multiple sequences together, allowing them to send different types of values.">zip_with_variant</a> </dd>
<dd>
<a class="el" href="namespacedi_1_1container_1_1view.html#a23256042ce7c04f4dd611149b13d7065">view::zip</a> </dd></dl>

</div>
</div>
<a id="acc8be53f60722f84d102c011699172ac" name="acc8be53f60722f84d102c011699172ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8be53f60722f84d102c011699172ac">&#9670;&#160;</a></span>zip_with_variant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto di::execution::zip_with_variant = <a class="el" href="structdi_1_1execution_1_1zip__ns_1_1VariantFunction.html">zip_ns::VariantFunction</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip multiple sequences together, allowing them to send different types of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequences</td><td>The sequences to zip together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence sender that sends each value of each sequence together.</dd></dl>
<p>This function is like <a class="el" href="namespacedi_1_1container_1_1view.html#a23256042ce7c04f4dd611149b13d7065">view::zip()</a> for ranges, but for sequences. Unlike <a class="el" href="#ad70a9cea178eec6ca25e6163042fea06" title="Zip multiple sequences together.">zip()</a>, the senders are allowed to send different types of values. The values will be sent as a variant.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad70a9cea178eec6ca25e6163042fea06" title="Zip multiple sequences together.">zip</a> </dd>
<dd>
<a class="el" href="namespacedi_1_1container_1_1view.html#a23256042ce7c04f4dd611149b13d7065">view::zip</a> </dd>
<dd>
<a class="el" href="#a2657238be4f5696647e228e7ab49a996" title="Transform the values of a sequence into a variant.">into_variant_each</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedi.html">di</a></li><li class="navelem"><a class="el" href="namespacedi_1_1execution.html">execution</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
