<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.10.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Iros: Intrusive Containers</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    Iros
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2di_2intrusive.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Intrusive Containers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md54"></a> </p>
<h1><a class="anchor" id="autotoc_md55"></a>
Comparison with Owning Containers</h1>
<p>Traditionally, containers "own" the elements which they reference. For instance, <code>di::Vector&lt;T&gt;</code> internally allocates memory to store each element in the vector. As a consequence, there it is inconvient to store the same value of type <code>T</code> in multiple containers.</p>
<p>Intrusive containers allow the container itself to use the space inside of an element <code>T</code> as part of the storage. This scheme allows data structures like linked-lists and trees to be efficently implemented without allocation. Storing nodes on the stack is useful in cases where the a thread needs to store add itself to a linked list, and then block. Also, in multi-threaded applications, an intrusive container protected by a lock can be used without needing to access the global allocator. This is criticial in kernelspace, because allocation is fallible and requires synchronization. By using intrusive containers, kernel code doesn't need to handle insertion failures, and doesn't hold locks to containers while performing the actual allocation.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Main Concern with Intrusive Containers</h1>
<p>The main issue with intrusive containers is that they do not have owner-ship semantics. In particular, there is no way to enforce that the nodes being referenced are valid. Sometimes this is by design, when allocating on the stack before blocking. In other cases, code must make use of reference-counting to ensure object validity.</p>
<p>Another important point is that, from an implementation perspective, it would be nice to implement owning containers in terms of intrusive containers. This ensures that the 2 containers will have feature parity. But to do so, we need to introduce some customization points for intrusive containers.</p>
<h1><a class="anchor" id="autotoc_md57"></a>
Intrusive Container Customizations</h1>
<p>The intrusive container implementation has 6 customization points.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tag::node_type(di::InPlaceType&lt;T&gt;) -&gt; Tag::Node   </td><td class="markdownTableBodyNone">Get the correct node type for a given T.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tag::down_cast(di::InPlaceType&lt;T&gt;, Tag::Node&amp; node) -&gt; T&amp;   </td><td class="markdownTableBodyNone">Cast from a node type to the underlying T value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tag::is_sized(di::InPlaceType&lt;T&gt;) -&gt; bool   </td><td class="markdownTableBodyNone">Determines whether the container offers an O(1) size function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tag::always_store_tail(di::InPlaceType&lt;T&gt;) -&gt; bool   </td><td class="markdownTableBodyNone">Determines whether a ForwardList offers O(1) back() and push_back().    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tag::did_insert(IntrusiveContainer&amp;, Tag::Node&amp; node)   </td><td class="markdownTableBodyNone">Hook which intrusive container calls just after inserting the node.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tag::did_remove(IntrusiveContainer&amp;, Tag::Node&amp; node)   </td><td class="markdownTableBodyNone">Hook which intrusive container calls just after removing the node.   </td></tr>
</table>
<p>Notice, there are 2 hooks which are called when inserting and removing elements, respectively. This is used so that reference-counted objects can take a reference on insertion and drop a reference on removal. The <code>did_remove</code> hook will be used by the owning containers to delete the object directly. As an implementation note, the last template parameter of the intrusive containers is the IntrusiveContainer type to pass the hooks. This allows user code to have the hook called with their own subclass and node type.</p>
<p>The <code>down_cast</code> method is used to convert from an internal node to a value of type <code>T</code>. This is needed so that the container's iterator will function correctly.</p>
<p>Additionally, each <code>Tag</code> passed to the container has an associated <code>Node</code> type, which is required to conform to the container's requirements. This means that the <code>Node</code> type must either be the container's node base class, or the <code>Node</code> type must publically inherit from it. Internally, intrusive containers will downcast their internal pointers to the <code>Node</code> type before calling these customizations.</p>
<p>The <code>Tag</code> also can customize whether or not the intrusive container stores a size. By standard C++, the owning list type should store the list's size. However, there is no need to store the size unless it is specifically needed.</p>
<p>In addition, the <code>Tag</code> can custommize whether or a <code>ForwardList</code> will store a pointer to the tail. This allows providing a <code>.back()</code> and <code>.push_back()</code> functions, which makes the container usable with the <code>di::Queue</code> adapter. This is enabled by default for normal intrusive containers, but by standard C++, the owning variant will not provide this functionality.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
Using the IntrusiveList class</h1>
<p>Types which want to be added to an <code>IntrusiveList</code> can use the following snippet.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyType : <span class="keyword">public</span> di::IntrusiveListElement&lt;&gt; {};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> test() {</div>
<div class="line">    <span class="keyword">auto</span> my_list = di::IntrusiveList&lt;MyType&gt; {};</div>
<div class="line">    <span class="keyword">auto</span> x = MyType {};</div>
<div class="line">    my_list.push_back(x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>To create a custom type, declare it like so and then inherit from the correct list element helper.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTag : <a class="code hl_struct" href="structdi_1_1container_1_1IntrusiveListTag.html">di::IntrusiveListTag</a>&lt;MyTag&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyType : <span class="keyword">public</span> <a class="code hl_class" href="classdi_1_1container_1_1IntrusiveListNode.html">di::IntrusiveListNode</a>&lt;MyTag&gt; {};</div>
<div class="ttc" id="aclassdi_1_1container_1_1IntrusiveListNode_html"><div class="ttname"><a href="classdi_1_1container_1_1IntrusiveListNode.html">di::container::IntrusiveListNode</a></div><div class="ttdef"><b>Definition</b> list_node.h:9</div></div>
<div class="ttc" id="astructdi_1_1container_1_1IntrusiveListTag_html"><div class="ttname"><a href="structdi_1_1container_1_1IntrusiveListTag.html">di::container::IntrusiveListTag</a></div><div class="ttdef"><b>Definition</b> list.h:18</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> test() {</div>
<div class="line">    <span class="keyword">auto</span> my_list = di::IntrusiveList&lt;MyType, MyTag&gt; {};</div>
<div class="line">    <span class="keyword">auto</span> x = MyType {};</div>
<div class="line">    my_list.push_back(x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As another example, to create a Type which needs shared ownership, a custom Tag can be used. In the future, there could even be a helper tag-type to implement this pattern. Also, under this approach, there needs to be some action which drops the last reference to <code>MyType</code>, since its initial reference count is 1.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTag;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyType : <span class="keyword">public</span> <a class="code hl_class" href="classdi_1_1container_1_1IntrusiveListNode.html">di::IntrusiveListNode</a>&lt;MyTag&gt;, <a class="code hl_struct" href="structdi_1_1vocab_1_1IntrusiveRefCount.html">di::IntrusiveRefCount</a>&lt;MyType&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyTag : <a class="code hl_struct" href="structdi_1_1container_1_1IntrusiveListTag.html">di::IntrusiveListTag</a>&lt;MyTag&gt; {</div>
<div class="line">    <span class="keyword">using </span>Node = <a class="code hl_struct" href="structdi_1_1container_1_1IntrusiveListTag.html">di::IntrusiveListTag&lt;MyTag&gt;::Node</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keywordtype">void</span> did_insert(di::InPlaceType&lt;MyType&gt; t, Node&amp; node) {</div>
<div class="line">        <span class="keyword">auto</span>&amp; value = MyTag::down_cast(t, node);</div>
<div class="line">        <span class="keyword">auto</span> to_leak = di::Arc&lt;MyType&gt;(node, di::adopt_object);</div>
<div class="line">        (void) to_leak.release();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keywordtype">void</span> did_remove(di::InPlaceType&lt;MyType&gt; t, Node&amp; node) {</div>
<div class="line">        <span class="keyword">auto</span>&amp; value = MyTag::down_cast(t, node);</div>
<div class="line">        <span class="keyword">auto</span> to_drop = di::Arc&lt;MyType&gt;(node, di::retain_object);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="astructdi_1_1vocab_1_1IntrusiveRefCount_html"><div class="ttname"><a href="structdi_1_1vocab_1_1IntrusiveRefCount.html">di::vocab::IntrusiveRefCount</a></div><div class="ttdef"><b>Definition</b> arc.h:24</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Iros Project Documentation</a></li><li class="navelem"><a class="el" href="md_docs_2di_2table__of__contents.html">Di Library Documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
