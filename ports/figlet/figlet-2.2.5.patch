diff --git a/Makefile b/Makefile
index 5a51d51..f564a0c 100644
--- a/Makefile
+++ b/Makefile
@@ -19,26 +19,25 @@
 SHELL = /bin/sh
 
 # The C compiler and linker to use
-CC	= gcc
+CC	= x86_64-os_2-gcc
 CFLAGS	= -g -O2 -Wall
-LD	= gcc
-LDFLAGS =
+LD	= x86_64-os_2-gcc
+LDFLAGS = -T link.ld
 
 # Feature flags:
 #   define TLF_FONTS to use TOIlet TLF fonts
-XCFLAGS	= -DTLF_FONTS
-
+XCFLAGS	= 
 # Where to install files
-prefix	= /usr/local
+prefix	= $(ROOT)/ports/figlet
 
 # Where the executables should be put
-BINDIR	= $(prefix)/bin
+BINDIR	= $(prefix)/figlet/bin
 
 # Where the man page should be put
-MANDIR	= $(prefix)/man
+MANDIR	= $(prefix)/figlet/man
 
 # Where figlet will search first for fonts (the ".flf" files).
-DEFAULTFONTDIR = $(prefix)/share/figlet
+DEFAULTFONTDIR = /share/figlet
 # Use this definition if you can't put things in $(prefix)/share/figlet
 #DEFAULTFONTDIR = fonts
 
@@ -54,12 +53,12 @@ DEFAULTFONTFILE = standard
 
 VERSION	= 2.2.5
 DIST	= figlet-$(VERSION)
-OBJS	= figlet.o zipio.o crc.o inflate.o utf8.o
+OBJS	= figlet.o zipio.o crc.o inflate.o
 BINS	= figlet chkfont figlist showfigfonts
 MANUAL	= figlet.6 chkfont.6 figlist.6 showfigfonts.6
-DFILES	= Makefile Makefile.tc $(MANUAL) $(OBJS:.o=.c) chkfont.c getopt.c \
+DFILES	= Makefile Makefile.tc $(MANUAL) $(OBJS:.o=.c) chkfont.c \
 	  figlist showfigfonts CHANGES FAQ README LICENSE figfont.txt \
-	  crc.h inflate.h zipio.h utf8.h run-tests.sh figmagic
+	  crc.h inflate.h zipio.h run-tests.sh figmagic
 
 .c.o:
 	$(CC) -c $(CFLAGS) $(XCFLAGS) -DDEFAULTFONTDIR=\"$(DEFAULTFONTDIR)\" \
@@ -78,12 +77,10 @@ clean:
 
 install: all
 	mkdir -p $(DESTDIR)$(BINDIR)
-	mkdir -p $(DESTDIR)$(MANDIR)/man6
-	mkdir -p $(DESTDIR)$(DEFAULTFONTDIR)
+	mkdir -p $(DESTDIR)$(prefix)/figlet$(DEFAULTFONTDIR)
 	cp $(BINS) $(DESTDIR)$(BINDIR)
-	cp $(MANUAL) $(DESTDIR)$(MANDIR)/man6
-	cp fonts/*.flf $(DESTDIR)$(DEFAULTFONTDIR)
-	cp fonts/*.flc $(DESTDIR)$(DEFAULTFONTDIR)
+	cp fonts/*.flf $(DESTDIR)$(prefix)/figlet$(DEFAULTFONTDIR)
+	cp fonts/*.flc $(DESTDIR)$(prefix)/figlet$(DEFAULTFONTDIR)
 
 dist:
 	rm -Rf $(DIST) $(DIST).tar.gz
diff --git a/figlet.c b/figlet.c
index 3de795a..00db757 100644
--- a/figlet.c
+++ b/figlet.c
@@ -77,8 +77,6 @@
 #include "utf8.h"
 #endif
 
-#include "zipio.h"     /* Package for reading compressed files */
-
 #define MYSTRLEN(x) ((int)strlen(x)) /* Eliminate ANSI problem */
 
 #define DIRSEP '/'
@@ -350,15 +348,15 @@ char *s2;
 ****************************************************************************/
 
 void skiptoeol(fp)
-ZFILE *fp;
+FILE *fp;
 {
   int dummy;
 
-  while (dummy=Zgetc(fp),dummy!=EOF) {
+  while (dummy=fgetc(fp),dummy!=EOF) {
     if (dummy == '\n') return;
     if (dummy == '\r') {
-      dummy = Zgetc(fp);
-      if (dummy != EOF && dummy != '\n') Zungetc(dummy,fp);
+      dummy = fgetc(fp);
+      if (dummy != EOF && dummy != '\n') ungetc(dummy,fp);
       return;
       }
   }
@@ -376,19 +374,19 @@ ZFILE *fp;
 char *myfgets(line,maxlen,fp)
 char *line;
 int maxlen;
-ZFILE *fp;
+FILE *fp;
 {
   int c = 0;
   char *p;
 
   p = line;
-  while((c=Zgetc(fp))!=EOF&&maxlen) {
+  while((c=fgetc(fp))!=EOF&&maxlen) {
     *p++ = c;
     maxlen--;
     if (c=='\n') break;
     if (c=='\r') {
-      c = Zgetc(fp);
-      if (c != EOF && c != '\n') Zungetc(c,fp);
+      c = fgetc(fp);
+      if (c != EOF && c != '\n') ungetc(c,fp);
       *(p-1) = '\n';
       break;
       }
@@ -475,13 +473,13 @@ int infonum;
 
 ****************************************************************************/
 void readmagic(fp,magic)
-ZFILE *fp;
+FILE *fp;
 char *magic;
 {
   int i;
 
   for (i=0;i<4;i++) {
-    magic[i] = Zgetc(fp);
+    magic[i] = fgetc(fp);
     }
   magic[4] = 0;
   }
@@ -494,11 +492,11 @@ char *magic;
 
 ****************************************************************************/
 void skipws(fp)
-ZFILE *fp;
+FILE *fp;
 {
   int c;
-  while (c=Zgetc(fp),isascii(c)&&isspace(c)) ;
-  Zungetc(c,fp);
+  while (c=fgetc(fp),isascii(c)&&isspace(c)) ;
+  ungetc(c,fp);
   }
 
 /****************************************************************************
@@ -510,7 +508,7 @@ ZFILE *fp;
 
 ****************************************************************************/
 void readnum(fp,nump)
-ZFILE *fp;
+FILE *fp;
 inchr *nump;
 {
   int acc = 0;
@@ -521,34 +519,34 @@ inchr *nump;
   char digits[] = "0123456789ABCDEF";
 
   skipws(fp);
-  c = Zgetc(fp);
+  c = fgetc(fp);
   if (c=='-') {
     sign = -1;
     }
   else {
-    Zungetc(c,fp);
+    ungetc(c,fp);
     }
-  c = Zgetc(fp);
+  c = fgetc(fp);
   if (c=='0') {
-     c = Zgetc(fp);
+     c = fgetc(fp);
      if (c=='x'||c=='X') {
        base = 16;
        }
      else {
        base = 8;
-       Zungetc(c,fp);
+       ungetc(c,fp);
        }
     }
   else {
     base = 10;
-    Zungetc(c,fp);
+    ungetc(c,fp);
     }
 
-  while((c=Zgetc(fp))!=EOF) {
+  while((c=fgetc(fp))!=EOF) {
     c=toupper(c);
     p=strchr(digits,c);
     if (!p) {
-      Zungetc(c,fp);
+      ungetc(c,fp);
       *nump = acc * sign;
       return;
       }
@@ -569,18 +567,18 @@ inchr *nump;
 ****************************************************************************/
 
 inchr readTchar(fp)
-ZFILE *fp;
+FILE *fp;
 {
   inchr thechar;
   char next;
 
-  thechar=Zgetc(fp);
+  thechar=fgetc(fp);
   if (thechar=='\n' || thechar=='\r') { /* Handle badly-formatted file */
-    Zungetc(thechar,fp);
+    ungetc(thechar,fp);
     return '\0';
     }
   if (thechar!='\\') return thechar;
-  next=Zgetc(fp);
+  next=fgetc(fp);
   switch(next) {
     case 'a':
       return 7;
@@ -600,7 +598,7 @@ ZFILE *fp;
       return 11;
     default:
       if (next=='-' || next=='x' || (next>='0' && next<='9')) {
-        Zungetc(next,fp);
+        ungetc(next,fp);
         readnum(fp,&thechar);
         return thechar;
         }
@@ -618,14 +616,14 @@ ZFILE *fp;
 ****************************************************************************/
 
 inchr charsetname(fp)
-ZFILE *fp;
+FILE *fp;
 {
   inchr result;
 
   result = readTchar(fp);
   if (result == '\n' || result == '\r') {
     result = 0;
-    Zungetc(result,fp);
+    ungetc(result,fp);
     }
   return result;
   }
@@ -641,16 +639,16 @@ ZFILE *fp;
 
 void charset(n, controlfile)
 int n;
-ZFILE *controlfile;
+FILE *controlfile;
 {
   int ch;
 
   skipws(controlfile);
-  if (Zgetc(controlfile) != '9') {
+  if (fgetc(controlfile) != '9') {
     skiptoeol(controlfile);
     return;
     }
-  ch = Zgetc(controlfile);
+  ch = fgetc(controlfile);
   if (ch == '6') {
      gn[n] = 65536L * charsetname(controlfile) + 0x80;
      gndbl[n] = 0;
@@ -661,13 +659,13 @@ ZFILE *controlfile;
     skiptoeol(controlfile);
     return;
     }
-  ch = Zgetc(controlfile);
+  ch = fgetc(controlfile);
   if (ch == 'x') {
-     if (Zgetc(controlfile) != '9') {
+     if (fgetc(controlfile) != '9') {
        skiptoeol(controlfile);
        return;
        }
-     if (Zgetc(controlfile) != '4') {
+     if (fgetc(controlfile) != '4') {
        skiptoeol(controlfile);
        return;
        }
@@ -677,7 +675,7 @@ ZFILE *controlfile;
      skiptoeol(controlfile);
      return;
      }
-  Zungetc(ch, controlfile);
+  ungetc(ch, controlfile);
   skipws(controlfile);
   gn[n] = 65536L * charsetname(controlfile);
   gndbl[n] = 0;
@@ -693,12 +691,12 @@ ZFILE *controlfile;
 
 ****************************************************************************/
 
-ZFILE *FIGopen(name,suffix)
+FILE *FIGopen(name,suffix)
 char *name;
 char *suffix;
 {
   char *fontpath;
-  ZFILE *fontfile;
+  FILE *fontfile;
   struct stat st;
   int namelen;
 
@@ -722,7 +720,7 @@ char *suffix;
   return NULL;
 
 ok:
-  fontfile = Zopen(fontpath,"rb");
+  fontfile = fopen(fontpath,"rb");
   return fontfile;
 }
 
@@ -742,7 +740,7 @@ char *controlname;
   char dashcheck;
   inchr offset;
   int command;
-  ZFILE *controlfile;
+  FILE *controlfile;
 
   controlfile = FIGopen(controlname,CONTROLFILESUFFIX);
 
@@ -757,16 +755,16 @@ char *controlname;
   commandlistend = &(*commandlistend)->next;
   (*commandlistend) = NULL;
 
-  while(command=Zgetc(controlfile),command!=EOF) {
+  while(command=fgetc(controlfile),command!=EOF) {
     switch (command) {
       case 't': /* Translate */
         skipws(controlfile);
         firstch=readTchar(controlfile);
-        if ((dashcheck=Zgetc(controlfile))=='-') {
+        if ((dashcheck=fgetc(controlfile))=='-') {
           lastch=readTchar(controlfile);
           }
         else {
-          Zungetc(dashcheck,controlfile);
+          ungetc(dashcheck,controlfile);
           lastch=firstch;
           }
         skipws(controlfile);
@@ -784,7 +782,7 @@ char *controlname;
       case '5': case '6': case '7': case '8': case '9':
       case '-':
                 /* Mapping table entry */
-        Zungetc(command,controlfile);
+        ungetc(command,controlfile);
         readnum(controlfile,&firstch);
         skipws(controlfile);
 	readnum(controlfile,&lastch);
@@ -821,7 +819,7 @@ char *controlname;
       case 'g': /* ISO 2022 character set choices */
         multibyte = 0;
         skipws(controlfile);
-        command=Zgetc(controlfile);
+        command=fgetc(controlfile);
         switch (command) {
           case '0': /* define G0 charset */
             charset(0, controlfile);
@@ -837,12 +835,12 @@ char *controlname;
             break;
           case 'l': case 'L': /* define left half */
             skipws(controlfile);
-            gl = Zgetc(controlfile) - '0';
+            gl = fgetc(controlfile) - '0';
             skiptoeol(controlfile);
             break;
           case 'r': case 'R': /* define right half */
             skipws(controlfile);
-            gr = Zgetc(controlfile) - '0';
+            gr = fgetc(controlfile) - '0';
             skiptoeol(controlfile);
             break;
           default: /* meaningless "g" command */
@@ -854,7 +852,7 @@ char *controlname;
         skiptoeol(controlfile);
       }
     }
-  Zclose(controlfile);
+  fclose(controlfile);
 }
 
 
@@ -1127,7 +1125,7 @@ void clearline()
 ****************************************************************************/
 
 void readfontchar(file,theord)
-ZFILE *file;
+FILE *file;
 inchr theord;
 {
   int row,k;
@@ -1183,7 +1181,7 @@ void readfont()
   int maxlen,cmtlines,ffright2left;
   int smush,smush2;
   char fileline[MAXLEN+1],magicnum[5];
-  ZFILE *fontfile;
+  FILE *fontfile;
 
   fontfile = FIGopen(fontname,FONTFILESUFFIX);
 #ifdef TLF_FONTS
@@ -1278,7 +1276,7 @@ void readfont()
     sscanf(fileline,"%li",&theord)==1) {
     readfontchar(fontfile,theord);
     }
-  Zclose(fontfile);
+  fclose(fontfile);
 }
 
 
@@ -2013,6 +2011,7 @@ char *argv[];
 
   Myargc = argc;
   Myargv = argv;
+
   getparams();
   readcontrolfiles();
   readfont();
diff --git a/getopt.c b/getopt.c
deleted file mode 100644
index 4218991..0000000
--- a/getopt.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * *    @(#)getopt.c    2.3 (smail) 5/30/87 
- */
-
-/*
- * Here's something you've all been waiting for:  the AT&T public domain
- * source for getopt(3).  It is the code which was given out at the 1985
- * UNIFORUM conference in Dallas. I obtained it by electronic mail directly
- * from AT&T.  The people there assure me that it is indeed in the public
- * domain. 
- *
- * There is no manual page. That is because the one they gave out at UNIFORUM
- * was slightly different from the current System V Release 2 manual page. 
- * The difference apparently involved a note about the famous rules 5 and 6,
- * recommending using white space between an option and its first argument,
- * and not grouping options that have arguments. Getopt itself is currently
- * lenient about both of these things White space is allowed, but not
- * mandatory, and the last option in a group can have an argument.  That
- * particular version of the man page evidently has no official existence,
- * and my source at AT&T did not send a copy. The current SVR2 man page
- * reflects the actual behavior of this getopt. However, I am not about to
- * post a copy of anything licensed by AT&T. 
- */
-
-#ifdef BSD
- #include <strings.h>
-#else
- #define index strchr
- #include <string.h>
-#endif
-
-/* LINTLIBRARY */
-#ifndef NULL
-#define NULL    0
-#endif
-
-#define EOF    (-1)
-#define ERR(s, c)    if(opterr){\
-    extern int write(int, void *, unsigned);\
-    char errbuf[2];\
-    errbuf[0] = (char)c; errbuf[1] = '\n';\
-    (void) write(2, strlwr(argv[0]), (unsigned)strlen(argv[0]));\
-    (void) write(2, s, (unsigned)strlen(s));\
-    (void) write(2, errbuf, 2);}
-
-extern char    *index();
-
-int             opterr = 1;
-int             optind = 1;
-int             optopt;
-char           *optarg;
-
-int getopt(int argc, char *argv[], char *opts)
-{
-      static int      sp = 1;
-      register int    c;
-      register char  *cp;
-
-      if (sp == 1)
-      {
-            if (optind >= argc || argv[optind][0] != '-' ||
-                  argv[optind][1] == '\0')
-                        return (EOF);
-            else if (strcmp(argv[optind], "--") == 0)
-            {
-                  optind++;
-                  return (EOF);
-            }
-      }
-      optopt = c = argv[optind][sp];
-      if (c == ':' || (cp = index(opts, c)) == NULL)
-      {
-            ERR(": illegal option -- ", c);
-            if (argv[optind][++sp] == '\0')
-            {
-                  optind++;
-                  sp = 1;
-            }
-            return ('?');
-      }
-      if (*++cp == ':')
-      {
-            if (argv[optind][sp + 1] != '\0')
-                  optarg = &argv[optind++][sp + 1];
-            else if (++optind >= argc)
-            {
-                  ERR(": option requires an argument -- ", c);
-                  sp = 1;
-                  return ('?');
-            }
-            else  optarg = argv[optind++];
-            sp = 1;
-      }
-      else
-      {
-            if (argv[optind][++sp] == '\0')
-            {
-                  sp = 1;
-                  optind++;
-            }
-            optarg = NULL;
-      }
-      return (c);
-}
diff --git a/link.ld b/link.ld
new file mode 100644
index 0000000..a9bfc41
--- /dev/null
+++ b/link.ld
@@ -0,0 +1,45 @@
+OUTPUT_FORMAT("elf64-x86-64")
+OUTPUT_ARCH(i386:x86-64)
+
+/* Sets first thing to be executed to be start */
+ENTRY(_start)
+
+SECTIONS
+{
+    . = 0x400000 + SIZEOF_HEADERS;
+
+    .text :
+    {
+        KEEP(*(SORT_NONE(.init)))
+        *(.text.startup)
+        *(.text .text.*)
+        KEEP(*(SORT_NONE(.fini)))
+    }
+
+    /* Put read only data */
+    .rodata ALIGN(0x1000) :
+    {
+        *(.rodata .rodata.*)
+        *(.eh_frame)
+    }
+
+    /* Put data */
+    .data ALIGN(0x1000) :
+    {
+        *(.data)
+        *(.ctors)
+        *(.dtors)
+    }
+
+    /* Put uninitialized data */
+    .bss ALIGN(0x1000) :
+    {
+        *(COMMON)
+        *(.bss .bss.*)
+    }
+
+    /DISCARD/ : { 
+        *(.comment)
+        *(.debug*)
+    }
+}
\ No newline at end of file
diff --git a/utf8.c b/utf8.c
deleted file mode 100644
index b8338c1..0000000
--- a/utf8.c
+++ /dev/null
@@ -1,326 +0,0 @@
-#ifdef TLF_FONTS
-/*
- * Copyright (c) 2007 Alexey Vatchenko <av@bsdua.org>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#include <sys/types.h>
-
-#include <wchar.h>
-#include <arpa/inet.h>	/* for htonl() */
-
-#include "utf8.h"
-
-#define _NXT	0x80
-#define _SEQ2	0xc0
-#define _SEQ3	0xe0
-#define _SEQ4	0xf0
-#define _SEQ5	0xf8
-#define _SEQ6	0xfc
-
-#define _BOM	0xfeff
-
-static int __wchar_forbitten(wchar_t sym);
-static int __utf8_forbitten(u_char octet);
-
-static int
-__wchar_forbitten(wchar_t sym)
-{
-
-	/* Surrogate pairs */
-	if (sym >= 0xd800 && sym <= 0xdfff)
-		return (-1);
-
-	return (0);
-}
-
-static int
-__utf8_forbitten(u_char octet)
-{
-
-	switch (octet) {
-	case 0xc0:
-	case 0xc1:
-	case 0xf5:
-	case 0xff:
-		return (-1);
-	}
-
-	return (0);
-}
-
-/*
- * DESCRIPTION
- *	This function translates UTF-8 string into UCS-4 string (all symbols
- *	will be in local machine byte order).
- *
- *	It takes the following arguments:
- *	in	- input UTF-8 string. It can be null-terminated.
- *	insize	- size of input string in bytes.
- *	out	- result buffer for UCS-4 string. If out is NULL,
- *		function returns size of result buffer.
- *	outsize - size of out buffer in wide characters.
- *
- * RETURN VALUES
- *	The function returns size of result buffer (in wide characters).
- *	Zero is returned in case of error.
- *
- * CAVEATS
- *	1. If UTF-8 string contains zero symbols, they will be translated
- *	   as regular symbols.
- *	2. If UTF8_IGNORE_ERROR or UTF8_SKIP_BOM flag is set, sizes may vary
- *	   when `out' is NULL and not NULL. It's because of special UTF-8
- *	   sequences which may result in forbitten (by RFC3629) UNICODE
- *	   characters.  So, the caller must check return value every time and
- *	   not prepare buffer in advance (\0 terminate) but after calling this
- *	   function.
- */
-size_t
-utf8_to_wchar(const char *in, size_t insize, wchar_t *out, size_t outsize,
-    int flags)
-{
-	u_char *p, *lim;
-	wchar_t *wlim, high;
-	size_t n, total, i, n_bits;
-
-	if (in == NULL || insize == 0 || (outsize == 0 && out != NULL))
-		return (0);
-
-	total = 0;
-	p = (u_char *)in;
-	lim = p + insize;
-	wlim = out + outsize;
-
-	for (; p < lim; p += n) {
-		if (__utf8_forbitten(*p) != 0 &&
-		    (flags & UTF8_IGNORE_ERROR) == 0)
-			return (0);
-
-		/*
-		 * Get number of bytes for one wide character.
-		 */
-		n = 1;	/* default: 1 byte. Used when skipping bytes. */
-		if ((*p & 0x80) == 0)
-			high = (wchar_t)*p;
-		else if ((*p & 0xe0) == _SEQ2) {
-			n = 2;
-			high = (wchar_t)(*p & 0x1f);
-		} else if ((*p & 0xf0) == _SEQ3) {
-			n = 3;
-			high = (wchar_t)(*p & 0x0f);
-		} else if ((*p & 0xf8) == _SEQ4) {
-			n = 4;
-			high = (wchar_t)(*p & 0x07);
-		} else if ((*p & 0xfc) == _SEQ5) {
-			n = 5;
-			high = (wchar_t)(*p & 0x03);
-		} else if ((*p & 0xfe) == _SEQ6) {
-			n = 6;
-			high = (wchar_t)(*p & 0x01);
-		} else {
-			if ((flags & UTF8_IGNORE_ERROR) == 0)
-				return (0);
-			continue;
-		}
-
-		/* does the sequence header tell us truth about length? */
-		if (lim - p <= n - 1) {
-			if ((flags & UTF8_IGNORE_ERROR) == 0)
-				return (0);
-			n = 1;
-			continue;	/* skip */
-		}
-
-		/*
-		 * Validate sequence.
-		 * All symbols must have higher bits set to 10xxxxxx
-		 */
-		if (n > 1) {
-			for (i = 1; i < n; i++) {
-				if ((p[i] & 0xc0) != _NXT)
-					break;
-			}
-			if (i != n) {
-				if ((flags & UTF8_IGNORE_ERROR) == 0)
-					return (0);
-				n = 1;
-				continue;	/* skip */
-			}
-		}
-
-		total++;
-
-		if (out == NULL)
-			continue;
-
-		if (out >= wlim)
-			return (0);		/* no space left */
-
-		*out = 0;
-		n_bits = 0;
-		for (i = 1; i < n; i++) {
-			*out |= (wchar_t)(p[n - i] & 0x3f) << n_bits;
-			n_bits += 6;		/* 6 low bits in every byte */
-		}
-		*out |= high << n_bits;
-
-		if (*out == 0)			/* return at end of string */
-			break;
-
-		if (__wchar_forbitten(*out) != 0) {
-			if ((flags & UTF8_IGNORE_ERROR) == 0)
-				return (0);	/* forbitten character */
-			else {
-				total--;
-				out--;
-			}
-		} else if (*out == _BOM && (flags & UTF8_SKIP_BOM) != 0) {
-			total--;
-			out--;
-		}
-
-		out++;
-	}
-
-	return (total);
-}
-
-/*
- * DESCRIPTION
- *	This function translates UCS-4 symbols (given in local machine
- *	byte order) into UTF-8 string.
- *
- *	It takes the following arguments:
- *	in	- input unicode string. It can be null-terminated.
- *	insize	- size of input string in wide characters.
- *	out	- result buffer for utf8 string. If out is NULL,
- *		function returns size of result buffer.
- *	outsize - size of result buffer.
- *
- * RETURN VALUES
- *	The function returns size of result buffer (in bytes). Zero is returned
- *	in case of error.
- *
- * CAVEATS
- *	If UCS-4 string contains zero symbols, they will be translated
- *	as regular symbols.
- */
-size_t
-wchar_to_utf8(const wchar_t *in, size_t insize, char *out, size_t outsize,
-    int flags)
-{
-	wchar_t *w, *wlim, ch;
-	u_char *p, *lim, *oc;
-	size_t total, n;
-
-	if (in == NULL || insize == 0 || (outsize == 0 && out != NULL))
-		return (0);
-
-	w = (wchar_t *)in;
-	wlim = w + insize;
-	p = (u_char *)out;
-	lim = p + outsize;
-	total = 0;
-	for (; w < wlim; w++) {
-		if (__wchar_forbitten(*w) != 0) {
-			if ((flags & UTF8_IGNORE_ERROR) == 0)
-				return (0);
-			else
-				continue;
-		}
-
-		if (*w == _BOM && (flags & UTF8_SKIP_BOM) != 0)
-			continue;
-
-		if (*w < 0) {
-			if ((flags & UTF8_IGNORE_ERROR) == 0)
-				return (0);
-			continue;
-		} else if (*w <= 0x0000007f)
-			n = 1;
-		else if (*w <= 0x000007ff)
-			n = 2;
-		else if (*w <= 0x0000ffff)
-			n = 3;
-		else if (*w <= 0x001fffff)
-			n = 4;
-		else if (*w <= 0x03ffffff)
-			n = 5;
-		else /* if (*w <= 0x7fffffff) */
-			n = 6;
-
-		total += n;
-
-		if (out == NULL)
-			continue;
-
-		if (lim - p <= n - 1)
-			return (0);		/* no space left */
-
-		/* make it work under different endians */
-		ch = htonl(*w);
-		oc = (u_char *)&ch;
-		switch (n) {
-		case 1:
-			*p = oc[3];
-			break;
-
-		case 2:
-			p[1] = _NXT | (oc[3] & 0x3f);
-			p[0] = _SEQ2 | (oc[3] >> 6) | ((oc[2] & 0x07) << 2);
-			break;
-
-		case 3:
-			p[2] = _NXT | (oc[3] & 0x3f);
-			p[1] = _NXT | (oc[3] >> 6) | ((oc[2] & 0x0f) << 2);
-			p[0] = _SEQ3 | ((oc[2] & 0xf0) >> 4);
-			break;
-
-		case 4:
-			p[3] = _NXT | (oc[3] & 0x3f);
-			p[2] = _NXT | (oc[3] >> 6) | ((oc[2] & 0x0f) << 2);
-			p[1] = _NXT | ((oc[2] & 0xf0) >> 4) |
-			    ((oc[1] & 0x03) << 4);
-			p[0] = _SEQ4 | ((oc[1] & 0x1f) >> 2);
-			break;
-
-		case 5:
-			p[4] = _NXT | (oc[3] & 0x3f);
-			p[3] = _NXT | (oc[3] >> 6) | ((oc[2] & 0x0f) << 2);
-			p[2] = _NXT | ((oc[2] & 0xf0) >> 4) |
-			    ((oc[1] & 0x03) << 4);
-			p[1] = _NXT | (oc[1] >> 2);
-			p[0] = _SEQ5 | (oc[0] & 0x03);
-			break;
-
-		case 6:
-			p[5] = _NXT | (oc[3] & 0x3f);
-			p[4] = _NXT | (oc[3] >> 6) | ((oc[2] & 0x0f) << 2);
-			p[3] = _NXT | (oc[2] >> 4) | ((oc[1] & 0x03) << 4);
-			p[2] = _NXT | (oc[1] >> 2);
-			p[1] = _NXT | (oc[0] & 0x3f);
-			p[0] = _SEQ6 | ((oc[0] & 0x40) >> 6);
-			break;
-		}
-
-		/*
-		 * NOTE: do not check here for forbitten UTF-8 characters.
-		 * They cannot appear here because we do proper convertion.
-		 */
-
-		p += n;
-	}
-
-	return (total);
-}
-#endif /* TLF_FONTS */
diff --git a/utf8.h b/utf8.h
deleted file mode 100644
index 0631b8a..0000000
--- a/utf8.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2007 Alexey Vatchenko <av@bsdua.org>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * utf8: implementation of UTF-8 charset encoding (RFC3629).
- */
-#ifndef _UTF8_H_
-#define _UTF8_H_
-
-#include <sys/types.h>
-
-#include <wchar.h>
-
-#define UTF8_IGNORE_ERROR		0x01
-#define UTF8_SKIP_BOM			0x02
-
-__BEGIN_DECLS
-
-size_t		utf8_to_wchar(const char *in, size_t insize, wchar_t *out,
-		    size_t outsize, int flags);
-size_t		wchar_to_utf8(const wchar_t *in, size_t insize, char *out,
-		    size_t outsize, int flags);
-
-__END_DECLS
-
-#endif /* !_UTF8_H_ */
