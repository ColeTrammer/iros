<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.10.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Iros: Iris Kernel Overview</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    Iros
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2iris_2design_2overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iris Kernel Overview</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md166"></a> </p>
<h1><a class="anchor" id="autotoc_md167"></a>
Reason for Writing a New Kernel for Iros</h1>
<p>The main question here is why abandon development of the old kernel written in C for a new one. There are 2 primary reasons:</p>
<ol type="1">
<li>The old kernel was unmaintainable, and C++'s ability to add safe abstractions will improve the situtation. For one, RAII and the Result class make handling errors without leaking resources effectively trivial. Smart pointers should make memory safety bugs significantly less likely, and class templates like di::Synchronized should make thread-safety simpler.</li>
<li>The old kernel was modelled strictly off of POSIX, which includes an extremely large body of obsolete and duplicate functionality. Writing a kernel with asynchronicity in mind, and leaving userspace to emulate POSIX APIs, many of which are duplicated (think SYS-V semaphores vs. POSIX semaphores), will result in a much cleaner design.</li>
</ol>
<p>The current issues with the old kernel are mostly around poor handling of error conditions and frequent concurrency issues, which make the system very unstable when trying to do something like run GCC. Due to performance issues in the kernel, running GCC takes at least 10x longer than it would on linux, and that is only considering compiling a single file. Attempting to compile the entire code base would would most likely take hours, but GCC would crash first anyway, even on a single core processor.</p>
<p>There are also several missing features, like support for USB, newer hardware platforms like AHCI, or nvme, IP v6 networking, or even any form of audio playback. The benefits of using a microkernel architecture are that prototyping these sorts of drivers can be done in userspace, which makes common concerns like thread-safety, handling error conditions, and avoiding memory allocations at all cost, much less problematic.</p>
<p>If a new AHCI driver crashes, the system will still be operational and the driver can simply be restarted. Thread-safety is irrelevant if the driver only has 1 thread, and only communicates with the kernel through a pair of SPSC queues. Hypothetically, a userspace program could actually be debugged using gdb, without freezing the entire system. This will make developing this functionality way more managable.</p>
<p>Ultimately, the goal of this new kernel is to acheive good performance while also making development of new features easier.</p>
<h1><a class="anchor" id="autotoc_md168"></a>
Design Priorities of the Iris Kernel</h1>
<ol type="1">
<li>Asyncrounous</li>
<li>Minimal</li>
<li>Performant</li>
</ol>
<h2><a class="anchor" id="autotoc_md169"></a>
Aysynchronous</h2>
<p>By default, every system call should be non-blocking. Ideally, there will be exactly one mechanism by which processes can block themselves, and no others.</p>
<h2><a class="anchor" id="autotoc_md170"></a>
Minimal</h2>
<p>For security and robustness, as few components as possible should reside within the kernel. Therefore, the kernel will only handle scheduling, memory management, and direct hardware access.</p>
<h2><a class="anchor" id="autotoc_md171"></a>
Performant</h2>
<p>The core IPC mechanism needs to be fast and scalable. This minimizes any performance loss caused by using a micro-kernel.</p>
<h1><a class="anchor" id="autotoc_md172"></a>
Micro-Kernel vs. Monolithic Kernel</h1>
<p>In a "classical" monolithic kernel, all supervisor code, including all drivers, runs in ring 0 in the same singlular address space. In a micro-kernel architecture, as many components as possible are moved into separate processes, most hopefully running in ring 3.</p>
<h2><a class="anchor" id="autotoc_md173"></a>
Pros of a Micro-Kernel</h2>
<ul>
<li>Increased fault tolerance (if the NIC driver crashes, the system can keep running)</li>
<li>Increased security (it is much harder to exploit components not directly in the kernel)</li>
<li>Increased modularity (different components can be developed in isolation)</li>
</ul>
<h2><a class="anchor" id="autotoc_md174"></a>
Cons of a Micro-Kernel</h2>
<ul>
<li>Increased complexity (now, multiple different processes must orchestrate themselves together)</li>
<li>Relies on Inter-Process Communication (not the much simpler interface, function calls)</li>
<li>Reduced performance (more context switches, non-blocking APIs, IRQ dispatch, ...)</li>
<li>Requires complex work-arounds (like bootstrapping a file system so that programs can be loaded)</li>
</ul>
<h2><a class="anchor" id="autotoc_md175"></a>
Pros of a Monolithic Kernel</h2>
<ul>
<li>Components communicate directly using function calls</li>
<li>Increased performance (component communication has no overhead)</li>
</ul>
<h2><a class="anchor" id="autotoc_md176"></a>
Cons of a Monolithic Kernel</h2>
<ul>
<li>Large attack surface</li>
<li>Failures in less significant components can cause the entire kernel to panic</li>
</ul>
<h2><a class="anchor" id="autotoc_md177"></a>
General Analysis</h2>
<p>It is generally held that a micro-kernel architecture is superior, if doing so is actually viable (including achieving comparable performance). This quest has resulted in large amounts of academic research investigating the subject.</p>
<p>Sometimes, the performance loss caused by requiring IPC to communicate with the kernel can be mitigated by having the kernel execute a verifiably safe program provided by said component.</p>
<p>This technique is used by microkernels to handle hardware IRQs without waiting for a response from the underlying device driver. The driver only needs to provide a simple program which convinces the device the interrupt has been received. Then, the kernel arranges for the driver to be scheduled, at which point actual work will be done (e.g., notifying another component the disk read was successful). This 2 phase approach to interrupt handling can be considered to the Linux soft IRQ mechanism. Additionally, hybrid-poll based drivers can disable interrupts when the device is known to actively be doing work, and instead continually poll the device.</p>
<p>This technique is additionally not exclusive to micro-kernels. The eBPF feature of Linux allows userspace code to control program executing in kernel context. This has numerous use cases, including in AF_XDP, where it is used to filter incoming packets before they are handed off to higher layers of the network stack. Using this functionality, the network protocols (e.g. IP v6, TCP, TLS, etc.) can all be implemented directly in userspace.</p>
<h2><a class="anchor" id="autotoc_md178"></a>
File System Analysis</h2>
<p>Linux also provides the FUSE API for implementing file system drivers in userspace. This is considered valuable for prototyping file system implementations, but file system drivers are usually converted into kernel space versions, in order to achieve supererior performance.</p>
<p>A pure userspace file system implementation faces numerous challenges which make obtaining comparable performance difficult.</p>
<p>The first relevant issue is the so-called "page cache". There must be a centralized cache of memory to minimize memory usage and enable any application to access this cache. Therefore, the kernel must be able to manage the page cache entries with the helper of file system drivers (for example, to flush dirty pages out to disk).</p>
<p>Along with the "page cache", the results of path lookups should also be cached. Using Linux, the dirent cache is consulted along every step of the traversal. For optimal performance, this lookup must be done by a central authority. The result of path lookup is further complicated by the mutable nature of the file system. When a file is deleted, the central authority must be made aware of this deleting to not end up with a stale cache.</p>
<p>Another notable problem is that of frequent context switches. When a userspace program requests to read 2048 bytes from a file, they would likely make a request to some central authority. This request then gets routed to the proper userspace driver (if the requested page is not in the "page cache"). At this point, the device driver must locate the disk sector which contains the relevant data. In the simply case, this can be done without any communication with the disk driver. However, actually reading the data requires calling into the disk driver. Finally, when the disk driver receives a completion event, the chain unravels, passing through the device driver into the cetral authority and then back the requesting application. On a single-processor system, this requires at least 4 context switches.</p>
<p>However, imagine instead this scenario with a 16 core machine that is actively reading an entire 32 MiB file. When doing sufficently large amounts of IO, the effective operation cost be bounded by the speed of the disk itself. To read the 32 MiB file as quickly as possible, it is enough to ensure the disk's queue of read requests is always full. During this scenario, the separate processes will run on separate cores, communicating with each other through lock-less SPSC queues (think Linux io_uring). In this scenario, throughput is maximized, since the file system driver can submit multiple blocks to be read at once.</p>
<p>Notice, this requires the underlying application uses asynchronous IO itself, will allows it to drive more and more requests for data. When using a synchronous IO, the kernel would have to specutively prefetch subsequent sectors to acheive a similar effect.</p>
<p>The conclusion is thus that asynchronous IO can tolerate the increased context switches readily, and although there is higher latency when the "page cache" is missed, throughput should be unaffected.</p>
<h2><a class="anchor" id="autotoc_md179"></a>
IPC Wake Up</h2>
<p>Another serious issue to consider is the mechanism to wake tasks which have received requests over the IPC mechanism. In Linux io_uring, a system call (io_uring_enter) is used to notify the kernel there is work to do. Alternatively, an application can request the kernel busy-poll its submission queue for new entries. Note this assumes that the IPC is purely asynchronous.</p>
<p>In a multi-processing scenario, the responsible task could already be awake and busy, and thus the calling program needs not wakeup anyone. However, it is equally possible that the task needs to be awoken. To do this, the kernel itself must perform some sort of mediation. This could be implemented by calling into the kernel, which would then attempt to schedule the relevant task, before returning to the caller.</p>
<p>It would be nice if the caller could directly call into the responsible task (using an interrupt vector), but this cannot be considered scalable (given that only 255 vectors are available). More research would be needed to determine the optimal mechanism for this case. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Iros Project Documentation</a></li><li class="navelem"><a class="el" href="md_docs_2iris_2table__of__contents.html">Iris Kernel Documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
